{"version":3,"file":"flexible-connected-position-strategy.js","sourceRoot":"","sources":["../../../../../src/cdk/overlay/position/flexible-connected-position-strategy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PositionStrategy} from './position-strategy';\nimport {ElementRef} from '@angular/core';\nimport {ViewportRuler, CdkScrollable, ViewportScrollPosition} from '@angular/cdk/scrolling';\nimport {\n  ConnectedOverlayPositionChange,\n  ConnectionPositionPair,\n  ScrollingVisibility,\n  validateHorizontalPosition,\n  validateVerticalPosition,\n} from './connected-position';\nimport {Observable, Subscription, Subject, Observer} from 'rxjs';\nimport {OverlayReference} from '../overlay-reference';\nimport {isElementScrolledOutsideView, isElementClippedByScrolling} from './scroll-clip';\nimport {coerceCssPixelValue, coerceArray} from '@angular/cdk/coercion';\nimport {Platform} from '@angular/cdk/platform';\nimport {OverlayContainer} from '../overlay-container';\n\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n\n/** Possible values that can be set as the origin of a FlexibleConnectedPositionStrategy. */\nexport type FlexibleConnectedPositionStrategyOrigin = ElementRef | HTMLElement | Point;\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nexport class FlexibleConnectedPositionStrategy implements PositionStrategy {\n  /** The overlay to which this strategy is attached. */\n  private _overlayRef: OverlayReference;\n\n  /** Whether we're performing the very first positioning of the overlay. */\n  private _isInitialRender: boolean;\n\n  /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n  private _lastBoundingBoxSize = {width: 0, height: 0};\n\n  /** Whether the overlay was pushed in a previous positioning. */\n  private _isPushed = false;\n\n  /** Whether the overlay can be pushed on-screen on the initial open. */\n  private _canPush = true;\n\n  /** Whether the overlay can grow via flexible width/height after the initial open. */\n  private _growAfterOpen = false;\n\n  /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n  private _hasFlexibleDimensions = true;\n\n  /** Whether the overlay position is locked. */\n  private _positionLocked = false;\n\n  /** Cached origin dimensions */\n  private _originRect: ClientRect;\n\n  /** Cached overlay dimensions */\n  private _overlayRect: ClientRect;\n\n  /** Cached viewport dimensions */\n  private _viewportRect: ClientRect;\n\n  /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n  private _viewportMargin = 0;\n\n  /** The Scrollable containers used to check scrollable view properties on position change. */\n  private scrollables: CdkScrollable[] = [];\n\n  /** Ordered list of preferred positions, from most to least desirable. */\n  _preferredPositions: ConnectionPositionPair[] = [];\n\n  /** The origin element against which the overlay will be positioned. */\n  private _origin: FlexibleConnectedPositionStrategyOrigin;\n\n  /** The overlay pane element. */\n  private _pane: HTMLElement;\n\n  /** Whether the strategy has been disposed of already. */\n  private _isDisposed: boolean;\n\n  /**\n   * Parent element for the overlay panel used to constrain the overlay panel's size to fit\n   * within the viewport.\n   */\n  private _boundingBox: HTMLElement | null;\n\n  /** The last position to have been calculated as the best fit position. */\n  private _lastPosition: ConnectedPosition | null;\n\n  /** Subject that emits whenever the position changes. */\n  private _positionChanges = new Subject<ConnectedOverlayPositionChange>();\n\n  /** Subscription to viewport size changes. */\n  private _resizeSubscription = Subscription.EMPTY;\n\n  /** Default offset for the overlay along the x axis. */\n  private _offsetX = 0;\n\n  /** Default offset for the overlay along the y axis. */\n  private _offsetY = 0;\n\n  /** Selector to be used when finding the elements on which to set the transform origin. */\n  private _transformOriginSelector: string;\n\n  /** Amount of subscribers to the `positionChanges` stream. */\n  private _positionChangeSubscriptions = 0;\n\n  /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n  private _appliedPanelClasses: string[] = [];\n\n  /** Amount by which the overlay was pushed in each axis during the last time it was positioned. */\n  private _previousPushAmount: {x: number, y: number} | null;\n\n  /** Observable sequence of position changes. */\n  positionChanges: Observable<ConnectedOverlayPositionChange> =\n      new Observable((observer: Observer<ConnectedOverlayPositionChange>) => {\n        const subscription = this._positionChanges.subscribe(observer);\n        this._positionChangeSubscriptions++;\n\n        return () => {\n          subscription.unsubscribe();\n          this._positionChangeSubscriptions--;\n        };\n      });\n\n  /** Ordered list of preferred positions, from most to least desirable. */\n  get positions() {\n    return this._preferredPositions;\n  }\n\n  constructor(\n    connectedTo: FlexibleConnectedPositionStrategyOrigin,\n    private _viewportRuler: ViewportRuler,\n    private _document: Document,\n    // @breaking-change 8.0.0 `_platform` and `_overlayContainer` parameters to be made required.\n    private _platform?: Platform,\n    private _overlayContainer?: OverlayContainer) {\n    this.setOrigin(connectedTo);\n  }\n\n  /** Attaches this position strategy to an overlay. */\n  attach(overlayRef: OverlayReference): void {\n    if (this._overlayRef && overlayRef !== this._overlayRef) {\n      throw Error('This position strategy is already attached to an overlay');\n    }\n\n    this._validatePositions();\n\n    overlayRef.hostElement.classList.add(boundingBoxClass);\n\n    this._overlayRef = overlayRef;\n    this._boundingBox = overlayRef.hostElement;\n    this._pane = overlayRef.overlayElement;\n    this._isDisposed = false;\n    this._isInitialRender = true;\n    this._lastPosition = null;\n    this._resizeSubscription.unsubscribe();\n    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n      // When the window is resized, we want to trigger the next reposition as if it\n      // was an initial render, in order for the strategy to pick a new optimal position,\n      // otherwise position locking will cause it to stay at the old one.\n      this._isInitialRender = true;\n      this.apply();\n    });\n  }\n\n  /**\n   * Updates the position of the overlay element, using whichever preferred position relative\n   * to the origin best fits on-screen.\n   *\n   * The selection of a position goes as follows:\n   *  - If any positions fit completely within the viewport as-is,\n   *      choose the first position that does so.\n   *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\n   *      choose the position with the greatest available size modified by the positions' weight.\n   *  - If pushing is enabled, take the position that went off-screen the least and push it\n   *      on-screen.\n   *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n   * @docs-private\n   */\n  apply(): void {\n    // We shouldn't do anything if the strategy was disposed or we're on the server.\n    // @breaking-change 8.0.0 Remove `_platform` null check once it's guaranteed to be defined.\n    if (this._isDisposed || (this._platform && !this._platform.isBrowser)) {\n      return;\n    }\n\n    // If the position has been applied already (e.g. when the overlay was opened) and the\n    // consumer opted into locking in the position, re-use the old position, in order to\n    // prevent the overlay from jumping around.\n    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n      this.reapplyLastPosition();\n      return;\n    }\n\n    this._clearPanelClasses();\n    this._resetOverlayElementStyles();\n    this._resetBoundingBoxStyles();\n\n    // We need the bounding rects for the origin and the overlay to determine how to position\n    // the overlay relative to the origin.\n    // We use the viewport rect to determine whether a position would go off-screen.\n    this._viewportRect = this._getNarrowedViewportRect();\n    this._originRect = this._getOriginRect();\n    this._overlayRect = this._pane.getBoundingClientRect();\n\n    const originRect = this._originRect;\n    const overlayRect = this._overlayRect;\n    const viewportRect = this._viewportRect;\n\n    // Positions where the overlay will fit with flexible dimensions.\n    const flexibleFits: FlexibleFit[] = [];\n\n    // Fallback if none of the preferred positions fit within the viewport.\n    let fallback: FallbackPosition | undefined;\n\n    // Go through each of the preferred positions looking for a good fit.\n    // If a good fit is found, it will be applied immediately.\n    for (let pos of this._preferredPositions) {\n      // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n      let originPoint = this._getOriginPoint(originRect, pos);\n\n      // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n      // overlay in this position. We use the top-left corner for calculations and later translate\n      // this into an appropriate (top, left, bottom, right) style.\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n\n      // Calculate how well the overlay would fit into the viewport with this point.\n      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n\n      // If the overlay, without any further work, fits into the viewport, use this position.\n      if (overlayFit.isCompletelyWithinViewport) {\n        this._isPushed = false;\n        this._applyPosition(pos, originPoint);\n        return;\n      }\n\n      // If the overlay has flexible dimensions, we can use this position\n      // so long as there's enough space for the minimum dimensions.\n      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n        // Save positions where the overlay will fit with flexible dimensions. We will use these\n        // if none of the positions fit *without* flexible dimensions.\n        flexibleFits.push({\n          position: pos,\n          origin: originPoint,\n          overlayRect,\n          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n        });\n\n        continue;\n      }\n\n      // If the current preferred position does not fit on the screen, remember the position\n      // if it has more visible area on-screen than we've seen and move onto the next preferred\n      // position.\n      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n        fallback = {overlayFit, overlayPoint, originPoint, position: pos, overlayRect};\n      }\n    }\n\n    // If there are any positions where the overlay would fit with flexible dimensions, choose the\n    // one that has the greatest area available modified by the position's weight\n    if (flexibleFits.length) {\n      let bestFit: FlexibleFit | null = null;\n      let bestScore = -1;\n      for (const fit of flexibleFits) {\n        const score =\n            fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n        if (score > bestScore) {\n          bestScore = score;\n          bestFit = fit;\n        }\n      }\n\n      this._isPushed = false;\n      this._applyPosition(bestFit!.position, bestFit!.origin);\n      return;\n    }\n\n    // When none of the preferred positions fit within the viewport, take the position\n    // that went off-screen the least and attempt to push it on-screen.\n    if (this._canPush) {\n      // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n      this._isPushed = true;\n      this._applyPosition(fallback!.position, fallback!.originPoint);\n      return;\n    }\n\n    // All options for getting the overlay within the viewport have been exhausted, so go with the\n    // position that went off-screen the least.\n    this._applyPosition(fallback!.position, fallback!.originPoint);\n  }\n\n  detach() {\n    this._clearPanelClasses();\n    this._lastPosition = null;\n    this._previousPushAmount = null;\n    this._resizeSubscription.unsubscribe();\n  }\n\n  /** Cleanup after the element gets destroyed. */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n\n    // We can't use `_resetBoundingBoxStyles` here, because it resets\n    // some properties to zero, rather than removing them.\n    if (this._boundingBox) {\n      extendStyles(this._boundingBox.style, {\n        top: '',\n        left: '',\n        right: '',\n        bottom: '',\n        height: '',\n        width: '',\n        alignItems: '',\n        justifyContent: '',\n      } as CSSStyleDeclaration);\n    }\n\n    if (this._pane) {\n      this._resetOverlayElementStyles();\n    }\n\n    if (this._overlayRef) {\n      this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n    }\n\n    this.detach();\n    this._positionChanges.complete();\n    this._overlayRef = this._boundingBox = null!;\n    this._isDisposed = true;\n  }\n\n  /**\n   * This re-aligns the overlay element with the trigger in its last calculated position,\n   * even if a position higher in the \"preferred positions\" list would now fit. This\n   * allows one to re-align the panel without changing the orientation of the panel.\n   */\n  reapplyLastPosition(): void {\n    if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\n      this._originRect = this._getOriginRect();\n      this._overlayRect = this._pane.getBoundingClientRect();\n      this._viewportRect = this._getNarrowedViewportRect();\n\n      const lastPosition = this._lastPosition || this._preferredPositions[0];\n      const originPoint = this._getOriginPoint(this._originRect, lastPosition);\n\n      this._applyPosition(lastPosition, originPoint);\n    }\n  }\n\n  /**\n   * Sets the list of Scrollable containers that host the origin element so that\n   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n   * Scrollable must be an ancestor element of the strategy's origin element.\n   */\n  withScrollableContainers(scrollables: CdkScrollable[]) {\n    this.scrollables = scrollables;\n  }\n\n  /**\n   * Adds new preferred positions.\n   * @param positions List of positions options for this overlay.\n   */\n  withPositions(positions: ConnectedPosition[]): this {\n    this._preferredPositions = positions;\n\n    // If the last calculated position object isn't part of the positions anymore, clear\n    // it in order to avoid it being picked up if the consumer tries to re-apply.\n    if (positions.indexOf(this._lastPosition!) === -1) {\n      this._lastPosition = null;\n    }\n\n    this._validatePositions();\n\n    return this;\n  }\n\n  /**\n   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n   * @param margin Required margin between the overlay and the viewport edge in pixels.\n   */\n  withViewportMargin(margin: number): this {\n    this._viewportMargin = margin;\n    return this;\n  }\n\n  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n  withFlexibleDimensions(flexibleDimensions = true): this {\n    this._hasFlexibleDimensions = flexibleDimensions;\n    return this;\n  }\n\n  /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n  withGrowAfterOpen(growAfterOpen = true): this {\n    this._growAfterOpen = growAfterOpen;\n    return this;\n  }\n\n  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n  withPush(canPush = true): this {\n    this._canPush = canPush;\n    return this;\n  }\n\n  /**\n   * Sets whether the overlay's position should be locked in after it is positioned\n   * initially. When an overlay is locked in, it won't attempt to reposition itself\n   * when the position is re-applied (e.g. when the user scrolls away).\n   * @param isLocked Whether the overlay should locked in.\n   */\n  withLockedPosition(isLocked = true): this {\n    this._positionLocked = isLocked;\n    return this;\n  }\n\n  /**\n   * Sets the origin, relative to which to position the overlay.\n   * Using an element origin is useful for building components that need to be positioned\n   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n   * used for cases like contextual menus which open relative to the user's pointer.\n   * @param origin Reference to the new origin.\n   */\n  setOrigin(origin: FlexibleConnectedPositionStrategyOrigin): this {\n    this._origin = origin;\n    return this;\n  }\n\n  /**\n   * Sets the default offset for the overlay's connection point on the x-axis.\n   * @param offset New offset in the X axis.\n   */\n  withDefaultOffsetX(offset: number): this {\n    this._offsetX = offset;\n    return this;\n  }\n\n  /**\n   * Sets the default offset for the overlay's connection point on the y-axis.\n   * @param offset New offset in the Y axis.\n   */\n  withDefaultOffsetY(offset: number): this {\n    this._offsetY = offset;\n    return this;\n  }\n\n  /**\n   * Configures that the position strategy should set a `transform-origin` on some elements\n   * inside the overlay, depending on the current position that is being applied. This is\n   * useful for the cases where the origin of an animation can change depending on the\n   * alignment of the overlay.\n   * @param selector CSS selector that will be used to find the target\n   *    elements onto which to set the transform origin.\n   */\n  withTransformOriginOn(selector: string): this {\n    this._transformOriginSelector = selector;\n    return this;\n  }\n\n  /**\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n   */\n  private _getOriginPoint(originRect: ClientRect, pos: ConnectedPosition): Point {\n    let x: number;\n    if (pos.originX == 'center') {\n      // Note: when centering we should always use the `left`\n      // offset, otherwise the position will be wrong in RTL.\n      x = originRect.left + (originRect.width / 2);\n    } else {\n      const startX = this._isRtl() ? originRect.right : originRect.left;\n      const endX = this._isRtl() ? originRect.left : originRect.right;\n      x = pos.originX == 'start' ? startX : endX;\n    }\n\n    let y: number;\n    if (pos.originY == 'center') {\n      y = originRect.top + (originRect.height / 2);\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n\n    return {x, y};\n  }\n\n\n  /**\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n   * origin point to which the overlay should be connected.\n   */\n  private _getOverlayPoint(\n      originPoint: Point,\n      overlayRect: ClientRect,\n      pos: ConnectedPosition): Point {\n\n    // Calculate the (overlayStartX, overlayStartY), the start of the\n    // potential overlay position relative to the origin point.\n    let overlayStartX: number;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n    }\n\n    let overlayStartY: number;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n\n    // The (x, y) coordinates of the overlay.\n    return {\n      x: originPoint.x + overlayStartX,\n      y: originPoint.y + overlayStartY,\n    };\n  }\n\n  /** Gets how well an overlay at the given point will fit within the viewport. */\n  private _getOverlayFit(point: Point, overlay: ClientRect, viewport: ClientRect,\n    position: ConnectedPosition): OverlayFit {\n\n    let {x, y} = point;\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n\n    // Account for the offsets since they could push the overlay out of the viewport.\n    if (offsetX) {\n      x += offsetX;\n    }\n\n    if (offsetY) {\n      y += offsetY;\n    }\n\n    // How much the overlay would overflow at this position, on each side.\n    let leftOverflow = 0 - x;\n    let rightOverflow = (x + overlay.width) - viewport.width;\n    let topOverflow = 0 - y;\n    let bottomOverflow = (y + overlay.height) - viewport.height;\n\n    // Visible parts of the element on each axis.\n    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n    let visibleArea = visibleWidth * visibleHeight;\n\n    return {\n      visibleArea,\n      isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\n      fitsInViewportVertically: visibleHeight === overlay.height,\n      fitsInViewportHorizontally: visibleWidth == overlay.width,\n    };\n  }\n\n  /**\n   * Whether the overlay can fit within the viewport when it may resize either its width or height.\n   * @param fit How well the overlay fits in the viewport at some position.\n   * @param point The (x, y) coordinates of the overlat at some position.\n   * @param viewport The geometry of the viewport.\n   */\n  private _canFitWithFlexibleDimensions(fit: OverlayFit, point: Point, viewport: ClientRect) {\n    if (this._hasFlexibleDimensions) {\n      const availableHeight = viewport.bottom - point.y;\n      const availableWidth = viewport.right - point.x;\n      const minHeight = this._overlayRef.getConfig().minHeight;\n      const minWidth = this._overlayRef.getConfig().minWidth;\n\n      const verticalFit = fit.fitsInViewportVertically ||\n          (minHeight != null && minHeight <= availableHeight);\n      const horizontalFit = fit.fitsInViewportHorizontally ||\n          (minWidth != null && minWidth <= availableWidth);\n\n      return verticalFit && horizontalFit;\n    }\n  }\n\n  /**\n   * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n   * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\n   * right and bottom).\n   *\n   * @param start Starting point from which the overlay is pushed.\n   * @param overlay Dimensions of the overlay.\n   * @param scrollPosition Current viewport scroll position.\n   * @returns The point at which to position the overlay after pushing. This is effectively a new\n   *     originPoint.\n   */\n  private _pushOverlayOnScreen(start: Point,\n                               overlay: ClientRect,\n                               scrollPosition: ViewportScrollPosition): Point {\n    // If the position is locked and we've pushed the overlay already, reuse the previous push\n    // amount, rather than pushing it again. If we were to continue pushing, the element would\n    // remain in the viewport, which goes against the expectations when position locking is enabled.\n    if (this._previousPushAmount && this._positionLocked) {\n      return {\n        x: start.x + this._previousPushAmount.x,\n        y: start.y + this._previousPushAmount.y\n      };\n    }\n\n    const viewport = this._viewportRect;\n\n    // Determine how much the overlay goes outside the viewport on each\n    // side, which we'll use to decide which direction to push it.\n    const overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);\n    const overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);\n    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n\n    // Amount by which to push the overlay in each axis such that it remains on-screen.\n    let pushX = 0;\n    let pushY = 0;\n\n    // If the overlay fits completely within the bounds of the viewport, push it from whichever\n    // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n    // viewport and allow for the trailing end of the overlay to go out of bounds.\n    if (overlay.width <= viewport.width) {\n      pushX = overflowLeft || -overflowRight;\n    } else {\n      pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;\n    }\n\n    if (overlay.height <= viewport.height) {\n      pushY = overflowTop || -overflowBottom;\n    } else {\n      pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;\n    }\n\n    this._previousPushAmount = {x: pushX, y: pushY};\n\n    return {\n      x: start.x + pushX,\n      y: start.y + pushY,\n    };\n  }\n\n  /**\n   * Applies a computed position to the overlay and emits a position change.\n   * @param position The position preference\n   * @param originPoint The point on the origin element where the overlay is connected.\n   */\n  private _applyPosition(position: ConnectedPosition, originPoint: Point) {\n    this._setTransformOrigin(position);\n    this._setOverlayElementStyles(originPoint, position);\n    this._setBoundingBoxStyles(originPoint, position);\n\n    if (position.panelClass) {\n      this._addPanelClasses(position.panelClass);\n    }\n\n    // Save the last connected position in case the position needs to be re-calculated.\n    this._lastPosition = position;\n\n    // Notify that the position has been changed along with its change properties.\n    // We only emit if we've got any subscriptions, because the scroll visibility\n    // calculcations can be somewhat expensive.\n    if (this._positionChangeSubscriptions > 0) {\n      const scrollableViewProperties = this._getScrollVisibility();\n      const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n      this._positionChanges.next(changeEvent);\n    }\n\n    this._isInitialRender = false;\n  }\n\n  /** Sets the transform origin based on the configured selector and the passed-in position.  */\n  private _setTransformOrigin(position: ConnectedPosition) {\n    if (!this._transformOriginSelector) {\n      return;\n    }\n\n    const elements: NodeListOf<HTMLElement> =\n        this._boundingBox!.querySelectorAll(this._transformOriginSelector);\n    let xOrigin: 'left' | 'right' | 'center';\n    let yOrigin: 'top' | 'bottom' | 'center' = position.overlayY;\n\n    if (position.overlayX === 'center') {\n      xOrigin = 'center';\n    } else if (this._isRtl()) {\n      xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n    } else {\n      xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n    }\n\n    for (let i = 0; i < elements.length; i++) {\n      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n    }\n  }\n\n  /**\n   * Gets the position and size of the overlay's sizing container.\n   *\n   * This method does no measuring and applies no styles so that we can cheaply compute the\n   * bounds for all positions and choose the best fit based on these results.\n   */\n  private _calculateBoundingBoxRect(origin: Point, position: ConnectedPosition): BoundingBoxRect {\n    const viewport = this._viewportRect;\n    const isRtl = this._isRtl();\n    let height: number, top: number, bottom: number;\n\n    if (position.overlayY === 'top') {\n      // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n      top = origin.y;\n      height = viewport.height - top + this._viewportMargin;\n    } else if (position.overlayY === 'bottom') {\n      // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n      // the viewport margin back in, because the viewport rect is narrowed down to remove the\n      // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n      bottom = viewport.height - origin.y + this._viewportMargin * 2;\n      height = viewport.height - bottom + this._viewportMargin;\n    } else {\n      // If neither top nor bottom, it means that the overlay is vertically centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n      // `origin.y - viewport.top`.\n      const smallestDistanceToViewportEdge =\n          Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n\n      const previousHeight = this._lastBoundingBoxSize.height;\n\n      height = smallestDistanceToViewportEdge * 2;\n      top = origin.y - smallestDistanceToViewportEdge;\n\n      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n        top = origin.y - (previousHeight / 2);\n      }\n    }\n\n    // The overlay is opening 'right-ward' (the content flows to the right).\n    const isBoundedByRightViewportEdge =\n        (position.overlayX === 'start' && !isRtl) ||\n        (position.overlayX === 'end' && isRtl);\n\n    // The overlay is opening 'left-ward' (the content flows to the left).\n    const isBoundedByLeftViewportEdge =\n        (position.overlayX === 'end' && !isRtl) ||\n        (position.overlayX === 'start' && isRtl);\n\n    let width: number, left: number, right: number;\n\n    if (isBoundedByLeftViewportEdge) {\n      right = viewport.right - origin.x + this._viewportMargin;\n      width = origin.x - viewport.left;\n    } else if (isBoundedByRightViewportEdge) {\n      left = origin.x;\n      width = viewport.right - origin.x;\n    } else {\n      // If neither start nor end, it means that the overlay is horizontally centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.right - origin.x` and\n      // `origin.x - viewport.left`.\n      const smallestDistanceToViewportEdge =\n          Math.min(viewport.right - origin.x + viewport.left, origin.x);\n      const previousWidth = this._lastBoundingBoxSize.width;\n\n      width = smallestDistanceToViewportEdge * 2;\n      left = origin.x - smallestDistanceToViewportEdge;\n\n      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n        left = origin.x - (previousWidth / 2);\n      }\n    }\n\n    return {top: top!, left: left!, bottom: bottom!, right: right!, width, height};\n  }\n\n  /**\n   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n   * origin's connection point and stetches to the bounds of the viewport.\n   *\n   * @param origin The point on the origin element where the overlay is connected.\n   * @param position The position preference\n   */\n  private _setBoundingBoxStyles(origin: Point, position: ConnectedPosition): void {\n    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n\n    // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n    // when applying a new size.\n    if (!this._isInitialRender && !this._growAfterOpen) {\n      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n    }\n\n    const styles = {} as CSSStyleDeclaration;\n\n    if (this._hasExactPosition()) {\n      styles.top = styles.left = '0';\n      styles.bottom = styles.right = '';\n      styles.width = styles.height = '100%';\n    } else {\n      const maxHeight = this._overlayRef.getConfig().maxHeight;\n      const maxWidth = this._overlayRef.getConfig().maxWidth;\n\n      styles.height = coerceCssPixelValue(boundingBoxRect.height);\n      styles.top = coerceCssPixelValue(boundingBoxRect.top);\n      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n      styles.width = coerceCssPixelValue(boundingBoxRect.width);\n      styles.left = coerceCssPixelValue(boundingBoxRect.left);\n      styles.right = coerceCssPixelValue(boundingBoxRect.right);\n\n      // Push the pane content towards the proper direction.\n      if (position.overlayX === 'center') {\n        styles.alignItems = 'center';\n      } else {\n        styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n      }\n\n      if (position.overlayY === 'center') {\n        styles.justifyContent = 'center';\n      } else {\n        styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n      }\n\n      if (maxHeight) {\n        styles.maxHeight = coerceCssPixelValue(maxHeight);\n      }\n\n      if (maxWidth) {\n        styles.maxWidth = coerceCssPixelValue(maxWidth);\n      }\n    }\n\n    this._lastBoundingBoxSize = boundingBoxRect;\n\n    extendStyles(this._boundingBox!.style, styles);\n  }\n\n  /** Resets the styles for the bounding box so that a new positioning can be computed. */\n  private _resetBoundingBoxStyles() {\n    extendStyles(this._boundingBox!.style, {\n      top: '0',\n      left: '0',\n      right: '0',\n      bottom: '0',\n      height: '',\n      width: '',\n      alignItems: '',\n      justifyContent: '',\n    } as CSSStyleDeclaration);\n  }\n\n  /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n  private _resetOverlayElementStyles() {\n    extendStyles(this._pane.style, {\n      top: '',\n      left: '',\n      bottom: '',\n      right: '',\n      position: '',\n      transform: '',\n    } as CSSStyleDeclaration);\n  }\n\n  /** Sets positioning styles to the overlay element. */\n  private _setOverlayElementStyles(originPoint: Point, position: ConnectedPosition): void {\n    const styles = {} as CSSStyleDeclaration;\n\n    if (this._hasExactPosition()) {\n      const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n    } else {\n      styles.position = 'static';\n    }\n\n    // Use a transform to apply the offsets. We do this because the `center` positions rely on\n    // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n    // off the position. We also can't use margins, because they won't have an effect in some\n    // cases where the element doesn't have anything to \"push off of\". Finally, this works\n    // better both with flexible and non-flexible positioning.\n    let transformString = '';\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n\n    if (offsetX) {\n      transformString += `translateX(${offsetX}px) `;\n    }\n\n    if (offsetY) {\n      transformString += `translateY(${offsetY}px)`;\n    }\n\n    styles.transform = transformString.trim();\n\n    // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n    // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n    // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n    if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight) {\n      styles.maxHeight = '';\n    }\n\n    if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth) {\n      styles.maxWidth = '';\n    }\n\n    extendStyles(this._pane.style, styles);\n  }\n\n  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n  private _getExactOverlayY(position: ConnectedPosition,\n                            originPoint: Point,\n                            scrollPosition: ViewportScrollPosition) {\n    // Reset any existing styles. This is necessary in case the\n    // preferred position has changed since the last `apply`.\n    let styles = {top: null, bottom: null} as CSSStyleDeclaration;\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n\n    // @breaking-change 8.0.0 Currently the `_overlayContainer` is optional in order to avoid a\n    // breaking change. The null check here can be removed once the `_overlayContainer` becomes\n    // a required parameter.\n    let virtualKeyboardOffset = this._overlayContainer ?\n        this._overlayContainer.getContainerElement().getBoundingClientRect().top : 0;\n\n    // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\n    // autocomplete), mobile browsers will shift everything in order to put the input in the middle\n    // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n    // otherwise our positioning will be thrown off.\n    overlayPoint.y -= virtualKeyboardOffset;\n\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n    // above or below the origin and the direction in which the element will expand.\n    if (position.overlayY === 'bottom') {\n      // When using `bottom`, we adjust the y position such that it is the distance\n      // from the bottom of the viewport rather than the top.\n      const documentHeight = this._document.documentElement!.clientHeight;\n      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n    } else {\n      styles.top = coerceCssPixelValue(overlayPoint.y);\n    }\n\n    return styles;\n  }\n\n  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n  private _getExactOverlayX(position: ConnectedPosition,\n                            originPoint: Point,\n                            scrollPosition: ViewportScrollPosition) {\n    // Reset any existing styles. This is necessary in case the preferred position has\n    // changed since the last `apply`.\n    let styles = {left: null, right: null} as CSSStyleDeclaration;\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n    // or \"after\" the origin, which determines the direction in which the element will expand.\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n    // page is in RTL or LTR.\n    let horizontalStyleProperty: 'left' | 'right';\n\n    if (this._isRtl()) {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n    } else {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n    }\n\n    // When we're setting `right`, we adjust the x position such that it is the distance\n    // from the right edge of the viewport rather than the left edge.\n    if (horizontalStyleProperty === 'right') {\n      const documentWidth = this._document.documentElement!.clientWidth;\n      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n    } else {\n      styles.left = coerceCssPixelValue(overlayPoint.x);\n    }\n\n    return styles;\n  }\n\n  /**\n   * Gets the view properties of the trigger and overlay, including whether they are clipped\n   * or completely outside the view of any of the strategy's scrollables.\n   */\n  private _getScrollVisibility(): ScrollingVisibility {\n    // Note: needs fresh rects since the position could've changed.\n    const originBounds = this._getOriginRect();\n    const overlayBounds =  this._pane.getBoundingClientRect();\n\n    // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n    // every time, we should be able to use the scrollTop of the containers if the size of those\n    // containers hasn't changed.\n    const scrollContainerBounds = this.scrollables.map(scrollable => {\n      return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n    });\n\n    return {\n      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n    };\n  }\n\n  /** Subtracts the amount that an element is overflowing on an axis from it's length. */\n  private _subtractOverflows(length: number, ...overflows: number[]): number {\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n\n  /** Narrows the given viewport rect by the current _viewportMargin. */\n  private _getNarrowedViewportRect(): ClientRect {\n    // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n    // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n    // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n    // and `innerHeight` that do. This is necessary, because the overlay container uses\n    // 100% `width` and `height` which don't include the scrollbar either.\n    const width = this._document.documentElement!.clientWidth;\n    const height = this._document.documentElement!.clientHeight;\n    const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n\n    return {\n      top:    scrollPosition.top + this._viewportMargin,\n      left:   scrollPosition.left + this._viewportMargin,\n      right:  scrollPosition.left + width - this._viewportMargin,\n      bottom: scrollPosition.top + height - this._viewportMargin,\n      width:  width  - (2 * this._viewportMargin),\n      height: height - (2 * this._viewportMargin),\n    };\n  }\n\n  /** Whether the we're dealing with an RTL context */\n  private _isRtl() {\n    return this._overlayRef.getDirection() === 'rtl';\n  }\n\n  /** Determines whether the overlay uses exact or flexible positioning. */\n  private _hasExactPosition() {\n    return !this._hasFlexibleDimensions || this._isPushed;\n  }\n\n  /** Retrieves the offset of a position along the x or y axis. */\n  private _getOffset(position: ConnectedPosition, axis: 'x' | 'y') {\n    if (axis === 'x') {\n      // We don't do something like `position['offset' + axis]` in\n      // order to avoid breking minifiers that rename properties.\n      return position.offsetX == null ? this._offsetX : position.offsetX;\n    }\n\n    return position.offsetY == null ? this._offsetY : position.offsetY;\n  }\n\n  /** Validates that the current position match the expected values. */\n  private _validatePositions(): void {\n    if (!this._preferredPositions.length) {\n      throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n    }\n\n    // TODO(crisbeto): remove these once Angular's template type\n    // checking is advanced enough to catch these cases.\n    this._preferredPositions.forEach(pair => {\n      validateHorizontalPosition('originX', pair.originX);\n      validateVerticalPosition('originY', pair.originY);\n      validateHorizontalPosition('overlayX', pair.overlayX);\n      validateVerticalPosition('overlayY', pair.overlayY);\n    });\n  }\n\n  /** Adds a single CSS class or an array of classes on the overlay panel. */\n  private _addPanelClasses(cssClasses: string | string[]) {\n    if (this._pane) {\n      coerceArray(cssClasses).forEach(cssClass => {\n        if (this._appliedPanelClasses.indexOf(cssClass) === -1) {\n          this._appliedPanelClasses.push(cssClass);\n          this._pane.classList.add(cssClass);\n        }\n      });\n    }\n  }\n\n  /** Clears the classes that the position strategy has applied from the overlay panel. */\n  private _clearPanelClasses() {\n    if (this._pane) {\n      this._appliedPanelClasses.forEach(cssClass => this._pane.classList.remove(cssClass));\n      this._appliedPanelClasses = [];\n    }\n  }\n\n  /** Returns the ClientRect of the current origin. */\n  private _getOriginRect(): ClientRect {\n    const origin = this._origin;\n\n    if (origin instanceof ElementRef) {\n      return origin.nativeElement.getBoundingClientRect();\n    }\n\n    if (origin instanceof HTMLElement) {\n      return origin.getBoundingClientRect();\n    }\n\n    // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n    return {\n      top: origin.y,\n      bottom: origin.y,\n      left: origin.x,\n      right: origin.x,\n      height: 0,\n      width: 0\n    };\n  }\n}\n\n/** A simple (x, y) coordinate. */\ninterface Point {\n  x: number;\n  y: number;\n}\n\n/** Record of measurements for how an overlay (at a given position) fits into the viewport. */\ninterface OverlayFit {\n  /** Whether the overlay fits completely in the viewport. */\n  isCompletelyWithinViewport: boolean;\n\n  /** Whether the overlay fits in the viewport on the y-axis. */\n  fitsInViewportVertically: boolean;\n\n  /** Whether the overlay fits in the viewport on the x-axis. */\n  fitsInViewportHorizontally: boolean;\n\n  /** The total visible area (in px^2) of the overlay inside the viewport. */\n  visibleArea: number;\n}\n\n/** Record of the measurments determining whether an overlay will fit in a specific position. */\ninterface FallbackPosition {\n  position: ConnectedPosition;\n  originPoint: Point;\n  overlayPoint: Point;\n  overlayFit: OverlayFit;\n  overlayRect: ClientRect;\n}\n\n/** Position and size of the overlay sizing wrapper for a specific position. */\ninterface BoundingBoxRect {\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n  height: number;\n  width: number;\n}\n\n/** Record of measures determining how well a given position will fit with flexible dimensions. */\ninterface FlexibleFit {\n  position: ConnectedPosition;\n  origin: Point;\n  overlayRect: ClientRect;\n  boundingBoxRect: BoundingBoxRect;\n}\n\n/** A connected position as specified by the user. */\nexport interface ConnectedPosition {\n  originX: 'start' | 'center' | 'end';\n  originY: 'top' | 'center' | 'bottom';\n\n  overlayX: 'start' | 'center' | 'end';\n  overlayY: 'top' | 'center' | 'bottom';\n\n  weight?: number;\n  offsetX?: number;\n  offsetY?: number;\n  panelClass?: string | string[];\n}\n\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(dest: CSSStyleDeclaration, source: CSSStyleDeclaration): CSSStyleDeclaration {\n  for (let key in source) {\n    if (source.hasOwnProperty(key)) {\n      dest[key] = source[key];\n    }\n  }\n\n  return dest;\n}\n"]}