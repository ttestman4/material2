{"version":3,"file":"virtual-scroll-viewport.js","sourceRoot":"","sources":["../../../../src/cdk/scrolling/virtual-scroll-viewport.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {ListRange} from '@angular/cdk/collections';\nimport {\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  Inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {animationFrameScheduler, Observable, Subject, Observer} from 'rxjs';\nimport {auditTime, startWith, takeUntil} from 'rxjs/operators';\nimport {ScrollDispatcher} from './scroll-dispatcher';\nimport {CdkScrollable, ExtendedScrollToOptions} from './scrollable';\nimport {CdkVirtualForOf} from './virtual-for-of';\nimport {VIRTUAL_SCROLL_STRATEGY, VirtualScrollStrategy} from './virtual-scroll-strategy';\n\n\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1: ListRange, r2: ListRange): boolean {\n  return r1.start == r2.start && r1.end == r2.end;\n}\n\n\n/** A viewport that virtualizes it's scrolling with the help of `CdkVirtualForOf`. */\n@Component({\n  moduleId: module.id,\n  selector: 'cdk-virtual-scroll-viewport',\n  templateUrl: 'virtual-scroll-viewport.html',\n  styleUrls: ['virtual-scroll-viewport.css'],\n  host: {\n    'class': 'cdk-virtual-scroll-viewport',\n    '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n    '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"',\n  },\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  providers: [{\n    provide: CdkScrollable,\n    useExisting: CdkVirtualScrollViewport,\n  }]\n})\nexport class CdkVirtualScrollViewport extends CdkScrollable implements OnInit, OnDestroy {\n  /** Emits when the viewport is detached from a CdkVirtualForOf. */\n  private _detachedSubject = new Subject<void>();\n\n  /** Emits when the rendered range changes. */\n  private _renderedRangeSubject = new Subject<ListRange>();\n\n  /** The direction the viewport scrolls. */\n  @Input() orientation: 'horizontal' | 'vertical' = 'vertical';\n\n  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n  // depending on how the strategy calculates the scrolled index, it may come at a cost to\n  // performance.\n  /** Emits when the index of the first element visible in the viewport changes. */\n  @Output() scrolledIndexChange: Observable<number> =\n      new Observable((observer: Observer<number>) =>\n        this._scrollStrategy.scrolledIndexChange.subscribe(index =>\n            Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n\n  /** The element that wraps the rendered content. */\n  @ViewChild('contentWrapper') _contentWrapper: ElementRef<HTMLElement>;\n\n  /** A stream that emits whenever the rendered range changes. */\n  renderedRangeStream: Observable<ListRange> = this._renderedRangeSubject.asObservable();\n\n  /**\n   * The transform used to scale the spacer to the same size as all content, including content that\n   * is not currently rendered.\n   */\n  _totalContentSizeTransform = '';\n\n  /**\n   * The total size of all content (in pixels), including content that is not currently rendered.\n   */\n  private _totalContentSize = 0;\n\n  /**\n   * The CSS transform applied to the rendered subset of items so that they appear within the bounds\n   * of the visible viewport.\n   */\n  private _renderedContentTransform: string;\n\n  /** The currently rendered range of indices. */\n  private _renderedRange: ListRange = {start: 0, end: 0};\n\n  /** The length of the data bound to this viewport (in number of items). */\n  private _dataLength = 0;\n\n  /** The size of the viewport (in pixels). */\n  private _viewportSize = 0;\n\n  /** the currently attached CdkVirtualForOf. */\n  private _forOf: CdkVirtualForOf<any> | null;\n\n  /** The last rendered content offset that was set. */\n  private _renderedContentOffset = 0;\n\n  /**\n   * Whether the last rendered content offset was to the end of the content (and therefore needs to\n   * be rewritten as an offset to the start of the content).\n   */\n  private _renderedContentOffsetNeedsRewrite = false;\n\n  /** Whether there is a pending change detection cycle. */\n  private _isChangeDetectionPending = false;\n\n  /** A list of functions to run after the next change detection cycle. */\n  private _runAfterChangeDetection: Function[] = [];\n\n  constructor(public elementRef: ElementRef<HTMLElement>,\n              private _changeDetectorRef: ChangeDetectorRef,\n              ngZone: NgZone,\n              @Optional() @Inject(VIRTUAL_SCROLL_STRATEGY)\n                  private _scrollStrategy: VirtualScrollStrategy,\n              @Optional() dir: Directionality,\n              scrollDispatcher: ScrollDispatcher) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n\n    if (!_scrollStrategy) {\n      throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n    }\n  }\n\n  ngOnInit() {\n    super.ngOnInit();\n\n    // It's still too early to measure the viewport at this point. Deferring with a promise allows\n    // the Viewport to be rendered with the correct size before we measure. We run this outside the\n    // zone to avoid causing more change detection cycles. We handle the change detection loop\n    // ourselves instead.\n    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n      this._measureViewportSize();\n      this._scrollStrategy.attach(this);\n\n      this.elementScrolled()\n          .pipe(\n              // Start off with a fake scroll event so we properly detect our initial position.\n              startWith<Event | null>(null!),\n              // Collect multiple events into one until the next animation frame. This way if\n              // there are multiple scroll events in the same frame we only need to recheck\n              // our layout once.\n              auditTime(0, animationFrameScheduler))\n          .subscribe(() => this._scrollStrategy.onContentScrolled());\n\n      this._markChangeDetectionNeeded();\n    }));\n  }\n\n  ngOnDestroy() {\n    this.detach();\n    this._scrollStrategy.detach();\n\n    // Complete all subjects\n    this._renderedRangeSubject.complete();\n    this._detachedSubject.complete();\n\n    super.ngOnDestroy();\n  }\n\n  /** Attaches a `CdkVirtualForOf` to this viewport. */\n  attach(forOf: CdkVirtualForOf<any>) {\n    if (this._forOf) {\n      throw Error('CdkVirtualScrollViewport is already attached.');\n    }\n\n    // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n    // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n    // change detection loop ourselves.\n    this.ngZone.runOutsideAngular(() => {\n      this._forOf = forOf;\n      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n        const newLength = data.length;\n        if (newLength !== this._dataLength) {\n          this._dataLength = newLength;\n          this._scrollStrategy.onDataLengthChanged();\n        }\n        this._doChangeDetection();\n      });\n    });\n  }\n\n  /** Detaches the current `CdkVirtualForOf`. */\n  detach() {\n    this._forOf = null;\n    this._detachedSubject.next();\n  }\n\n  /** Gets the length of the data bound to this viewport (in number of items). */\n  getDataLength(): number {\n    return this._dataLength;\n  }\n\n  /** Gets the size of the viewport (in pixels). */\n  getViewportSize(): number {\n    return this._viewportSize;\n  }\n\n  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n  // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n  // setting it to something else, but its error prone and should probably be split into\n  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n\n  /** Get the current rendered range of items. */\n  getRenderedRange(): ListRange {\n    return this._renderedRange;\n  }\n\n  /**\n   * Sets the total size of all content (in pixels), including content that is not currently\n   * rendered.\n   */\n  setTotalContentSize(size: number) {\n    if (this._totalContentSize !== size) {\n      this._totalContentSize = size;\n      const axis = this.orientation == 'horizontal' ? 'X' : 'Y';\n      this._totalContentSizeTransform = `scale${axis}(${this._totalContentSize})`;\n      this._markChangeDetectionNeeded();\n    }\n  }\n\n  /** Sets the currently rendered range of indices. */\n  setRenderedRange(range: ListRange) {\n    if (!rangesEqual(this._renderedRange, range)) {\n      this._renderedRangeSubject.next(this._renderedRange = range);\n      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n    }\n  }\n\n  /**\n   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n   */\n  getOffsetToRenderedContentStart(): number | null {\n    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n  }\n\n  /**\n   * Sets the offset from the start of the viewport to either the start or end of the rendered data\n   * (in pixels).\n   */\n  setRenderedContentOffset(offset: number, to: 'to-start' | 'to-end' = 'to-start') {\n    // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n    // in the negative direction.\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    const isHorizontal = this.orientation == 'horizontal';\n    const axis = isHorizontal ? 'X' : 'Y';\n    const axisDirection = isHorizontal && isRtl ? -1 : 1;\n    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n    this._renderedContentOffset = offset;\n    if (to === 'to-end') {\n      transform += ` translate${axis}(-100%)`;\n      // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n      // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n      // expand upward).\n      this._renderedContentOffsetNeedsRewrite = true;\n    }\n    if (this._renderedContentTransform != transform) {\n      // We know this value is safe because we parse `offset` with `Number()` before passing it\n      // into the string.\n      this._renderedContentTransform = transform;\n      this._markChangeDetectionNeeded(() => {\n        if (this._renderedContentOffsetNeedsRewrite) {\n          this._renderedContentOffset -= this.measureRenderedContentSize();\n          this._renderedContentOffsetNeedsRewrite = false;\n          this.setRenderedContentOffset(this._renderedContentOffset);\n        } else {\n          this._scrollStrategy.onRenderedOffsetChanged();\n        }\n      });\n    }\n  }\n\n  /**\n   * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n   * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n   * @param offset The offset to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToOffset(offset: number, behavior: ScrollBehavior = 'auto') {\n    const options: ExtendedScrollToOptions = {behavior};\n    if (this.orientation === 'horizontal') {\n      options.start = offset;\n    } else {\n      options.top = offset;\n    }\n    this.scrollTo(options);\n  }\n\n  /**\n   * Scrolls to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToIndex(index: number,  behavior: ScrollBehavior = 'auto') {\n    this._scrollStrategy.scrollToIndex(index, behavior);\n  }\n\n  /**\n   * Gets the current scroll offset from the start of the viewport (in pixels).\n   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n   *     in horizontal mode.\n   */\n  measureScrollOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number {\n    return super.measureScrollOffset(\n        from ? from : this.orientation === 'horizontal' ? 'start' : 'top');\n  }\n\n  /** Measure the combined size of all of the rendered items. */\n  measureRenderedContentSize(): number {\n    const contentEl = this._contentWrapper.nativeElement;\n    return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n  }\n\n  /**\n   * Measure the total combined size of the given range. Throws if the range includes items that are\n   * not rendered.\n   */\n  measureRangeSize(range: ListRange): number {\n    if (!this._forOf) {\n      return 0;\n    }\n    return this._forOf.measureRangeSize(range, this.orientation);\n  }\n\n  /** Update the viewport dimensions and re-render. */\n  checkViewportSize() {\n    // TODO: Cleanup later when add logic for handling content resize\n    this._measureViewportSize();\n    this._scrollStrategy.onDataLengthChanged();\n  }\n\n  /** Measure the viewport size. */\n  private _measureViewportSize() {\n    const viewportEl = this.elementRef.nativeElement;\n    this._viewportSize = this.orientation === 'horizontal' ?\n        viewportEl.clientWidth : viewportEl.clientHeight;\n  }\n\n  /** Queue up change detection to run. */\n  private _markChangeDetectionNeeded(runAfter?: Function) {\n    if (runAfter) {\n      this._runAfterChangeDetection.push(runAfter);\n    }\n\n    // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n    // properties sequentially we only have to run `_doChangeDetection` once at the end.\n    if (!this._isChangeDetectionPending) {\n      this._isChangeDetectionPending = true;\n      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n        this._doChangeDetection();\n      }));\n    }\n  }\n\n  /** Run change detection. */\n  private _doChangeDetection() {\n    this._isChangeDetectionPending = false;\n\n    // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n    // from the root, since the repeated items are content projected in. Calling `detectChanges`\n    // instead does not properly check the projected content.\n    this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n    // Apply the content transform. The transform can't be set via an Angular binding because\n    // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n    // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n    // the `Number` function first to coerce it to a numeric value.\n    this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n\n    const runAfterChangeDetection = this._runAfterChangeDetection;\n    this._runAfterChangeDetection = [];\n    for (const fn of runAfterChangeDetection) {\n      fn();\n    }\n  }\n}\n"]}