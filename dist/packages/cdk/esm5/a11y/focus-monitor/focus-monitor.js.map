{"version":3,"file":"focus-monitor.js","sourceRoot":"","sources":["../../../../../../src/cdk/a11y/focus-monitor/focus-monitor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  SkipSelf,\n} from '@angular/core';\nimport {Observable, of as observableOf, Subject, Subscription} from 'rxjs';\nimport {coerceElement} from '@angular/cdk/coercion';\n\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nexport const TOUCH_BUFFER_MS = 650;\n\n\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\n\n/**\n * Corresponds to the options that can be passed to the native `focus` event.\n * via https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n */\nexport interface FocusOptions {\n  /** Whether the browser should scroll to the element when it is focused. */\n  preventScroll?: boolean;\n}\n\ntype MonitoredElementInfo = {\n  unlisten: Function,\n  checkChildren: boolean,\n  subject: Subject<FocusOrigin>\n};\n\n/**\n * Event listener options that enable capturing and also\n * mark the the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n  passive: true,\n  capture: true\n});\n\n\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\n@Injectable({providedIn: 'root'})\nexport class FocusMonitor implements OnDestroy {\n  /** The focus origin that the next focus event is a result of. */\n  private _origin: FocusOrigin = null;\n\n  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n  private _lastFocusOrigin: FocusOrigin;\n\n  /** Whether the window has just been focused. */\n  private _windowFocused = false;\n\n  /** The target of the last touch event. */\n  private _lastTouchTarget: EventTarget | null;\n\n  /** The timeout id of the touch timeout, used to cancel timeout later. */\n  private _touchTimeoutId: number;\n\n  /** The timeout id of the window focus timeout. */\n  private _windowFocusTimeoutId: number;\n\n  /** The timeout id of the origin clearing timeout. */\n  private _originTimeoutId: number;\n\n  /** Map of elements being monitored to their info. */\n  private _elementInfo = new Map<HTMLElement, MonitoredElementInfo>();\n\n  /** The number of elements currently being monitored. */\n  private _monitoredElementCount = 0;\n\n  /**\n   * Event listener for `keydown` events on the document.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  private _documentKeydownListener = () => {\n    // On keydown record the origin and clear any touch event that may be in progress.\n    this._lastTouchTarget = null;\n    this._setOriginForCurrentEventQueue('keyboard');\n  }\n\n  /**\n   * Event listener for `mousedown` events on the document.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  private _documentMousedownListener = () => {\n    // On mousedown record the origin only if there is not touch\n    // target, since a mousedown can happen as a result of a touch event.\n    if (!this._lastTouchTarget) {\n      this._setOriginForCurrentEventQueue('mouse');\n    }\n  }\n\n  /**\n   * Event listener for `touchstart` events on the document.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  private _documentTouchstartListener = (event: TouchEvent) => {\n    // When the touchstart event fires the focus event is not yet in the event queue. This means\n    // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n    // see if a focus happens.\n    if (this._touchTimeoutId != null) {\n      clearTimeout(this._touchTimeoutId);\n    }\n    this._lastTouchTarget = event.target;\n    this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n  }\n\n  /**\n   * Event listener for `focus` events on the window.\n   * Needs to be an arrow function in order to preserve the context when it gets bound.\n   */\n  private _windowFocusListener = () => {\n    // Make a note of when the window regains focus, so we can\n    // restore the origin info for the focused element.\n    this._windowFocused = true;\n    this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\n  }\n\n  constructor(private _ngZone: NgZone, private _platform: Platform) {}\n\n  /**\n   * Monitors focus on an element and applies appropriate CSS classes.\n   * @param element The element to monitor\n   * @param checkChildren Whether to count the element as focused when its children are focused.\n   * @returns An observable that emits when the focus state of the element changes.\n   *     When the element is blurred, null will be emitted.\n   */\n  monitor(element: HTMLElement, checkChildren?: boolean): Observable<FocusOrigin>;\n\n  /**\n   * Monitors focus on an element and applies appropriate CSS classes.\n   * @param element The element to monitor\n   * @param checkChildren Whether to count the element as focused when its children are focused.\n   * @returns An observable that emits when the focus state of the element changes.\n   *     When the element is blurred, null will be emitted.\n   */\n  monitor(element: ElementRef<HTMLElement>, checkChildren?: boolean): Observable<FocusOrigin>;\n\n  monitor(element: HTMLElement | ElementRef<HTMLElement>,\n          checkChildren: boolean = false): Observable<FocusOrigin> {\n    // Do nothing if we're not on the browser platform.\n    if (!this._platform.isBrowser) {\n      return observableOf(null);\n    }\n\n    const nativeElement = coerceElement(element);\n\n    // Check if we're already monitoring this element.\n    if (this._elementInfo.has(nativeElement)) {\n      let cachedInfo = this._elementInfo.get(nativeElement);\n      cachedInfo!.checkChildren = checkChildren;\n      return cachedInfo!.subject.asObservable();\n    }\n\n    // Create monitored element info.\n    let info: MonitoredElementInfo = {\n      unlisten: () => {},\n      checkChildren: checkChildren,\n      subject: new Subject<FocusOrigin>()\n    };\n    this._elementInfo.set(nativeElement, info);\n    this._incrementMonitoredElementCount();\n\n    // Start listening. We need to listen in capture phase since focus events don't bubble.\n    let focusListener = (event: FocusEvent) => this._onFocus(event, nativeElement);\n    let blurListener = (event: FocusEvent) => this._onBlur(event, nativeElement);\n    this._ngZone.runOutsideAngular(() => {\n      nativeElement.addEventListener('focus', focusListener, true);\n      nativeElement.addEventListener('blur', blurListener, true);\n    });\n\n    // Create an unlisten function for later.\n    info.unlisten = () => {\n      nativeElement.removeEventListener('focus', focusListener, true);\n      nativeElement.removeEventListener('blur', blurListener, true);\n    };\n\n    return info.subject.asObservable();\n  }\n\n  /**\n   * Stops monitoring an element and removes all focus classes.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: HTMLElement): void;\n\n  /**\n   * Stops monitoring an element and removes all focus classes.\n   * @param element The element to stop monitoring.\n   */\n  stopMonitoring(element: ElementRef<HTMLElement>): void;\n\n  stopMonitoring(element: HTMLElement | ElementRef<HTMLElement>): void {\n    const nativeElement = coerceElement(element);\n    const elementInfo = this._elementInfo.get(nativeElement);\n\n    if (elementInfo) {\n      elementInfo.unlisten();\n      elementInfo.subject.complete();\n\n      this._setClasses(nativeElement);\n      this._elementInfo.delete(nativeElement);\n      this._decrementMonitoredElementCount();\n    }\n  }\n\n  /**\n   * Focuses the element via the specified focus origin.\n   * @param element Element to focus.\n   * @param origin Focus origin.\n   * @param options Options that can be used to configure the focus behavior.\n   */\n  focusVia(element: HTMLElement, origin: FocusOrigin, options?: FocusOptions): void;\n\n  /**\n   * Focuses the element via the specified focus origin.\n   * @param element Element to focus.\n   * @param origin Focus origin.\n   * @param options Options that can be used to configure the focus behavior.\n   */\n  focusVia(element: ElementRef<HTMLElement>, origin: FocusOrigin, options?: FocusOptions): void;\n\n  focusVia(element: HTMLElement | ElementRef<HTMLElement>,\n          origin: FocusOrigin,\n          options?: FocusOptions): void {\n\n    const nativeElement = coerceElement(element);\n\n    this._setOriginForCurrentEventQueue(origin);\n\n    // `focus` isn't available on the server\n    if (typeof nativeElement.focus === 'function') {\n      // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.\n      (nativeElement as any).focus(options);\n    }\n  }\n\n  ngOnDestroy() {\n    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n  }\n\n  private _toggleClass(element: Element, className: string, shouldSet: boolean) {\n    if (shouldSet) {\n      element.classList.add(className);\n    } else {\n      element.classList.remove(className);\n    }\n  }\n\n  /**\n   * Sets the focus classes on the element based on the given focus origin.\n   * @param element The element to update the classes on.\n   * @param origin The focus origin.\n   */\n  private _setClasses(element: HTMLElement, origin?: FocusOrigin): void {\n    const elementInfo = this._elementInfo.get(element);\n\n    if (elementInfo) {\n      this._toggleClass(element, 'cdk-focused', !!origin);\n      this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n      this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n      this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n      this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n    }\n  }\n\n  /**\n   * Sets the origin and schedules an async function to clear it at the end of the event queue.\n   * @param origin The origin to set.\n   */\n  private _setOriginForCurrentEventQueue(origin: FocusOrigin): void {\n    this._ngZone.runOutsideAngular(() => {\n      this._origin = origin;\n      // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n      // tick after the interaction event fired. To ensure the focus origin is always correct,\n      // the focus origin will be determined at the beginning of the next tick.\n      this._originTimeoutId = setTimeout(() => this._origin = null, 1);\n    });\n  }\n\n  /**\n   * Checks whether the given focus event was caused by a touchstart event.\n   * @param event The focus event to check.\n   * @returns Whether the event was caused by a touch.\n   */\n  private _wasCausedByTouch(event: FocusEvent): boolean {\n    // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n    // Consider the following dom structure:\n    //\n    // <div #parent tabindex=\"0\" cdkFocusClasses>\n    //   <div #child (click)=\"#parent.focus()\"></div>\n    // </div>\n    //\n    // If the user touches the #child element and the #parent is programmatically focused as a\n    // result, this code will still consider it to have been caused by the touch event and will\n    // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n    // relatively small edge-case that can be worked around by using\n    // focusVia(parentEl, 'program') to focus the parent element.\n    //\n    // If we decide that we absolutely must handle this case correctly, we can do so by listening\n    // for the first focus event after the touchstart, and then the first blur event after that\n    // focus event. When that blur event fires we know that whatever follows is not a result of the\n    // touchstart.\n    let focusTarget = event.target;\n    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n        (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n  }\n\n  /**\n   * Handles focus events on a registered element.\n   * @param event The focus event.\n   * @param element The monitored element.\n   */\n  private _onFocus(event: FocusEvent, element: HTMLElement) {\n    // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n    // focus event affecting the monitored element. If we want to use the origin of the first event\n    // instead we should check for the cdk-focused class here and return if the element already has\n    // it. (This only matters for elements that have includesChildren = true).\n\n    // If we are not counting child-element-focus as focused, make sure that the event target is the\n    // monitored element itself.\n    const elementInfo = this._elementInfo.get(element);\n    if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n      return;\n    }\n\n    // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n    // 1) The window has just regained focus, in which case we want to restore the focused state of\n    //    the element from before the window blurred.\n    // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n    // 3) The element was programmatically focused, in which case we should mark the origin as\n    //    'program'.\n    let origin = this._origin;\n    if (!origin) {\n      if (this._windowFocused && this._lastFocusOrigin) {\n        origin = this._lastFocusOrigin;\n      } else if (this._wasCausedByTouch(event)) {\n        origin = 'touch';\n      } else {\n        origin = 'program';\n      }\n    }\n\n    this._setClasses(element, origin);\n    this._emitOrigin(elementInfo.subject, origin);\n    this._lastFocusOrigin = origin;\n  }\n\n  /**\n   * Handles blur events on a registered element.\n   * @param event The blur event.\n   * @param element The monitored element.\n   */\n  _onBlur(event: FocusEvent, element: HTMLElement) {\n    // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n    // order to focus another child of the monitored element.\n    const elementInfo = this._elementInfo.get(element);\n\n    if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n        element.contains(event.relatedTarget))) {\n      return;\n    }\n\n    this._setClasses(element);\n    this._emitOrigin(elementInfo.subject, null);\n  }\n\n  private _emitOrigin(subject: Subject<FocusOrigin>, origin: FocusOrigin) {\n    this._ngZone.run(() => subject.next(origin));\n  }\n\n  private _incrementMonitoredElementCount() {\n    // Register global listeners when first element is monitored.\n    if (++this._monitoredElementCount == 1 && this._platform.isBrowser) {\n      // Note: we listen to events in the capture phase so we\n      // can detect them even if the user stops propagation.\n      this._ngZone.runOutsideAngular(() => {\n        document.addEventListener('keydown', this._documentKeydownListener,\n          captureEventListenerOptions);\n        document.addEventListener('mousedown', this._documentMousedownListener,\n          captureEventListenerOptions);\n        document.addEventListener('touchstart', this._documentTouchstartListener,\n          captureEventListenerOptions);\n        window.addEventListener('focus', this._windowFocusListener);\n      });\n    }\n  }\n\n  private _decrementMonitoredElementCount() {\n    // Unregister global listeners when last element is unmonitored.\n    if (!--this._monitoredElementCount) {\n      document.removeEventListener('keydown', this._documentKeydownListener,\n        captureEventListenerOptions);\n      document.removeEventListener('mousedown', this._documentMousedownListener,\n        captureEventListenerOptions);\n      document.removeEventListener('touchstart', this._documentTouchstartListener,\n        captureEventListenerOptions);\n      window.removeEventListener('focus', this._windowFocusListener);\n\n      // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n      clearTimeout(this._windowFocusTimeoutId);\n      clearTimeout(this._touchTimeoutId);\n      clearTimeout(this._originTimeoutId);\n    }\n  }\n}\n\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\n@Directive({\n  selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n})\nexport class CdkMonitorFocus implements OnDestroy {\n  private _monitorSubscription: Subscription;\n  @Output() cdkFocusChange = new EventEmitter<FocusOrigin>();\n\n  constructor(private _elementRef: ElementRef<HTMLElement>, private _focusMonitor: FocusMonitor) {\n    this._monitorSubscription = this._focusMonitor.monitor(\n        this._elementRef,\n        this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n        .subscribe(origin => this.cdkFocusChange.emit(origin));\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n    this._monitorSubscription.unsubscribe();\n  }\n}\n\n/** @docs-private @deprecated @breaking-change 8.0.0 */\nexport function FOCUS_MONITOR_PROVIDER_FACTORY(\n    parentDispatcher: FocusMonitor, ngZone: NgZone, platform: Platform) {\n  return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n\n/** @docs-private @deprecated @breaking-change 8.0.0 */\nexport const FOCUS_MONITOR_PROVIDER = {\n  // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n  provide: FocusMonitor,\n  deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n  useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n"]}