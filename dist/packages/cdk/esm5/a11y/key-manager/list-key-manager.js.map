{"version":3,"file":"list-key-manager.js","sourceRoot":"","sources":["../../../../../../src/cdk/a11y/key-manager/list-key-manager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {QueryList} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\nimport {\n  UP_ARROW,\n  DOWN_ARROW,\n  LEFT_ARROW,\n  RIGHT_ARROW,\n  TAB,\n  A,\n  Z,\n  ZERO,\n  NINE,\n  hasModifierKey,\n} from '@angular/cdk/keycodes';\nimport {debounceTime, filter, map, tap} from 'rxjs/operators';\n\n/** This interface is for items that can be passed to a ListKeyManager. */\nexport interface ListKeyManagerOption {\n  /** Whether the option is disabled. */\n  disabled?: boolean;\n\n  /** Gets the label for this option. */\n  getLabel?(): string;\n}\n\n/** Modifier keys handled by the ListKeyManager. */\nexport type ListKeyManagerModifierKey = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\n  private _activeItemIndex = -1;\n  private _activeItem: T | null = null;\n  private _wrap = false;\n  private _letterKeyStream = new Subject<string>();\n  private _typeaheadSubscription = Subscription.EMPTY;\n  private _vertical = true;\n  private _horizontal: 'ltr' | 'rtl' | null;\n  private _allowedModifierKeys: ListKeyManagerModifierKey[] = [];\n\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  private _skipPredicateFn = (item: T) => item.disabled;\n\n  // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n  private _pressedLetters: string[] = [];\n\n  constructor(private _items: QueryList<T> | T[]) {\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      _items.changes.subscribe((newItems: QueryList<T>) => {\n        if (this._activeItem) {\n          const itemArray = newItems.toArray();\n          const newIndex = itemArray.indexOf(this._activeItem);\n\n          if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n            this._activeItemIndex = newIndex;\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  tabOut: Subject<void> = new Subject<void>();\n\n  /** Stream that emits whenever the active item of the list manager changes. */\n  change = new Subject<number>();\n\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate: (item: T) => boolean): this {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true): this {\n    this._wrap = shouldWrap;\n    return this;\n  }\n\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled: boolean = true): this {\n    this._vertical = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n    this._horizontal = direction;\n    return this;\n  }\n\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys: ListKeyManagerModifierKey[]): this {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval: number = 200): this {\n    if (this._items.length && this._items.some(item => typeof item.getLabel !== 'function')) {\n      throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n    }\n\n    this._typeaheadSubscription.unsubscribe();\n\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n    // and convert those letters back into a string. Afterwards find the first item that starts\n    // with that string and select it.\n    this._typeaheadSubscription = this._letterKeyStream.pipe(\n      tap(keyCode => this._pressedLetters.push(keyCode)),\n      debounceTime(debounceInterval),\n      filter(() => this._pressedLetters.length > 0),\n      map(() => this._pressedLetters.join(''))\n    ).subscribe(inputString => {\n      const items = this._getItemsArray();\n\n      // Start at 1 because we want to start searching at the item immediately\n      // following the current active item.\n      for (let i = 1; i < items.length + 1; i++) {\n        const index = (this._activeItemIndex + i) % items.length;\n        const item = items[index];\n\n        if (!this._skipPredicateFn(item) &&\n            item.getLabel!().toUpperCase().trim().indexOf(inputString) === 0) {\n\n          this.setActiveItem(index);\n          break;\n        }\n      }\n\n      this._pressedLetters = [];\n    });\n\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the index specified.\n   * @param index The index of the item to be set as active.\n   */\n  setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T): void;\n\n  setActiveItem(item: any): void {\n    const previousIndex = this._activeItemIndex;\n\n    this.updateActiveItem(item);\n\n    if (this._activeItemIndex !== previousIndex) {\n      this.change.next(this._activeItemIndex);\n    }\n  }\n\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const modifiers: ListKeyManagerModifierKey[] = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      default:\n      if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n          // otherwise fall back to resolving alphanumeric characters via the keyCode.\n          if (event.key && event.key.length === 1) {\n            this._letterKeyStream.next(event.key.toLocaleUpperCase());\n          } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n            this._letterKeyStream.next(String.fromCharCode(keyCode));\n          }\n        }\n\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    this._pressedLetters = [];\n    event.preventDefault();\n  }\n\n  /** Index of the currently active item. */\n  get activeItemIndex(): number | null {\n    return this._activeItemIndex;\n  }\n\n  /** The active item. */\n  get activeItem(): T | null {\n    return this._activeItem;\n  }\n\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive(): void {\n    this._setActiveItemByIndex(this._items.length - 1, -1);\n  }\n\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive(): void {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive(): void {\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n                                            : this._setActiveItemByDelta(-1);\n  }\n\n  /**\n   * Allows setting the active without any other effects.\n   * @param index Index of the item to be set as active.\n   */\n  updateActiveItem(index: number): void;\n\n  /**\n   * Allows setting the active item without any other effects.\n   * @param item Item to be set as active.\n   */\n  updateActiveItem(item: T): void;\n\n  updateActiveItem(item: any): void {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem = activeItem == null ? null : activeItem;\n    this._activeItemIndex = index;\n  }\n\n  /**\n   * Allows setting of the activeItemIndex without any other effects.\n   * @param index The new activeItemIndex.\n   * @deprecated Use `updateActiveItem` instead.\n   * @breaking-change 8.0.0\n   */\n  updateActiveItemIndex(index: number): void {\n    this.updateActiveItem(index);\n  }\n\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  private _setActiveItemByDelta(delta: -1 | 1): void {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  private _setActiveInWrapMode(delta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n      const item = items[index];\n\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  private _setActiveInDefaultMode(delta: -1 | 1): void {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n  }\n\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  private _setActiveItemByIndex(index: number, fallbackDelta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    if (!items[index]) {\n      return;\n    }\n\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n\n      if (!items[index]) {\n        return;\n      }\n    }\n\n    this.setActiveItem(index);\n  }\n\n  /** Returns the items as an array. */\n  private _getItemsArray(): T[] {\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n}\n"]}