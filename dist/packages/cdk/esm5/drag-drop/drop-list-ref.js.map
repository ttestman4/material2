{"version":3,"file":"drop-list-ref.js","sourceRoot":"","sources":["../../../../../src/cdk/drag-drop/drop-list-ref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementRef} from '@angular/core';\nimport {DragDropRegistry} from './drag-drop-registry';\nimport {Direction} from '@angular/cdk/bidi';\nimport {Subject} from 'rxjs';\nimport {moveItemInArray} from './drag-utils';\nimport {DragRefInternal as DragRef} from './drag-ref';\n\n\n/** Counter used to generate unique ids for drop refs. */\nlet _uniqueIdCounter = 0;\n\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n\n/**\n * Entry in the position cache for draggable items.\n * @docs-private\n */\ninterface CachedItemPosition {\n  /** Instance of the drag item. */\n  drag: DragRef;\n  /** Dimensions of the item. */\n  clientRect: ClientRect;\n  /** Amount by which the item has been moved since dragging started. */\n  offset: number;\n}\n\n/**\n * Internal compile-time-only representation of a `DropListRef`.\n * Used to avoid circular import issues between the `DropListRef` and the `DragRef`.\n * @docs-private\n */\nexport interface DropListRefInternal extends DropListRef {}\n\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * @docs-private\n */\nexport class DropListRef<T = any> {\n  private _document: Document;\n\n  /** Element that the drop list is attached to. */\n  readonly element: HTMLElement;\n\n  /**\n   * Unique ID for the drop list.\n   * @deprecated No longer being used. To be removed.\n   * @breaking-change 8.0.0\n   */\n  id = `cdk-drop-list-ref-${_uniqueIdCounter++}`;\n\n  /** Whether starting a dragging sequence from this container is disabled. */\n  disabled: boolean = false;\n\n  /** Locks the position of the draggable elements inside the container along the specified axis. */\n  lockAxis: 'x' | 'y';\n\n  /**\n   * Function that is used to determine whether an item\n   * is allowed to be moved into a drop container.\n   */\n  enterPredicate: (drag: DragRef, drop: DropListRef) => boolean = () => true;\n\n  /** Emits right before dragging has started. */\n  beforeStarted = new Subject<void>();\n\n  /**\n   * Emits when the user has moved a new drag item into this container.\n   */\n  entered = new Subject<{item: DragRef, container: DropListRef}>();\n\n  /**\n   * Emits when the user removes an item from the container\n   * by dragging it into another container.\n   */\n  exited = new Subject<{item: DragRef, container: DropListRef}>();\n\n  /** Emits when the user drops an item inside the container. */\n  dropped = new Subject<{\n    item: DragRef,\n    currentIndex: number,\n    previousIndex: number,\n    container: DropListRef,\n    previousContainer: DropListRef,\n    isPointerOverContainer: boolean\n  }>();\n\n  /** Emits as the user is swapping items while actively dragging. */\n  sorted = new Subject<{\n    previousIndex: number,\n    currentIndex: number,\n    container: DropListRef,\n    item: DragRef\n  }>();\n\n  /** Arbitrary data that can be attached to the drop list. */\n  data: T;\n\n  /** Whether an item in the list is being dragged. */\n  private _isDragging = false;\n\n  /** Cache of the dimensions of all the items inside the container. */\n  private _itemPositions: CachedItemPosition[] = [];\n\n  /** Cached `ClientRect` of the drop list. */\n  private _clientRect: ClientRect;\n\n  /**\n   * Draggable items that are currently active inside the container. Includes the items\n   * from `_draggables`, as well as any items that have been dragged in, but haven't\n   * been dropped yet.\n   */\n  private _activeDraggables: DragRef[];\n\n  /**\n   * Keeps track of the item that was last swapped with the dragged item, as\n   * well as what direction the pointer was moving in when the swap occured.\n   */\n  private _previousSwap = {drag: null as DragRef | null, delta: 0};\n\n  /** Draggable items in the container. */\n  private _draggables: DragRef[];\n\n  /** Drop lists that are connected to the current one. */\n  private _siblings: DropListRef[] = [];\n\n  /** Direction in which the list is oriented. */\n  private _orientation: 'horizontal' | 'vertical' = 'vertical';\n\n  /** Connected siblings that currently have a dragged item. */\n  private _activeSiblings = new Set<DropListRef>();\n\n  /** Layout direction of the drop list. */\n  private _direction: Direction = 'ltr';\n\n  constructor(\n    element: ElementRef<HTMLElement> | HTMLElement,\n    private _dragDropRegistry: DragDropRegistry<DragRef, DropListRef>,\n    _document: any) {\n    _dragDropRegistry.registerDropContainer(this);\n    this._document = _document;\n    this.element = element instanceof ElementRef ? element.nativeElement : element;\n  }\n\n  /** Removes the drop list functionality from the DOM element. */\n  dispose() {\n    this.beforeStarted.complete();\n    this.entered.complete();\n    this.exited.complete();\n    this.dropped.complete();\n    this.sorted.complete();\n    this._activeSiblings.clear();\n    this._dragDropRegistry.removeDropContainer(this);\n  }\n\n  /** Whether an item from this list is currently being dragged. */\n  isDragging() {\n    return this._isDragging;\n  }\n\n  /** Starts dragging an item. */\n  start(): void {\n    this.beforeStarted.next();\n    this._isDragging = true;\n    this._activeDraggables = this._draggables.slice();\n    this._cacheOwnPosition();\n    this._cacheItemPositions();\n    this._siblings.forEach(sibling => sibling._startReceiving(this));\n  }\n\n  /**\n   * Emits an event to indicate that the user moved an item into the container.\n   * @param item Item that was moved into the container.\n   * @param pointerX Position of the item along the X axis.\n   * @param pointerY Position of the item along the Y axis.\n   */\n  enter(item: DragRef, pointerX: number, pointerY: number): void {\n    this.entered.next({item, container: this});\n    this.start();\n\n    // We use the coordinates of where the item entered the drop\n    // zone to figure out at which index it should be inserted.\n    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n    const currentIndex = this._activeDraggables.indexOf(item);\n    const newPositionReference = this._activeDraggables[newIndex];\n    const placeholder = item.getPlaceholderElement();\n\n    // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n    // into another container and back again), we have to ensure that it isn't duplicated.\n    if (currentIndex > -1) {\n      this._activeDraggables.splice(currentIndex, 1);\n    }\n\n    // Don't use items that are being dragged as a reference, because\n    // their element has been moved down to the bottom of the body.\n    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n      const element = newPositionReference.getRootElement();\n      element.parentElement!.insertBefore(placeholder, element);\n      this._activeDraggables.splice(newIndex, 0, item);\n    } else {\n      this.element.appendChild(placeholder);\n      this._activeDraggables.push(item);\n    }\n\n    // The transform needs to be cleared so it doesn't throw off the measurements.\n    placeholder.style.transform = '';\n\n    // Note that the positions were already cached when we called `start` above,\n    // but we need to refresh them since the amount of items has changed.\n    this._cacheItemPositions();\n  }\n\n  /**\n   * Removes an item from the container after it was dragged into another container by the user.\n   * @param item Item that was dragged out.\n   */\n  exit(item: DragRef): void {\n    this._reset();\n    this.exited.next({item, container: this});\n  }\n\n  /**\n   * Drops an item into this container.\n   * @param item Item being dropped into the container.\n   * @param currentIndex Index at which the item should be inserted.\n   * @param previousContainer Container from which the item got dragged in.\n   * @param isPointerOverContainer Whether the user's pointer was over the\n   *    container when the item was dropped.\n   */\n  drop(item: DragRef, currentIndex: number, previousContainer: DropListRef,\n    isPointerOverContainer: boolean): void {\n    this._reset();\n    this.dropped.next({\n      item,\n      currentIndex,\n      previousIndex: previousContainer.getItemIndex(item),\n      container: this,\n      previousContainer,\n      isPointerOverContainer\n    });\n  }\n\n  /**\n   * Sets the draggable items that are a part of this list.\n   * @param items Items that are a part of this list.\n   */\n  withItems(items: DragRef[]): this {\n    this._draggables = items.slice();\n    items.forEach(item => item._withDropContainer(this));\n    return this;\n  }\n\n  /** Sets the layout direction of the drop list. */\n  withDirection(direction: Direction): this {\n    this._direction = direction;\n    return this;\n  }\n\n  /**\n   * Sets the containers that are connected to this one. When two or more containers are\n   * connected, the user will be allowed to transfer items between them.\n   * @param connectedTo Other containers that the current containers should be connected to.\n   */\n  connectedTo(connectedTo: DropListRef[]): this {\n    this._siblings = connectedTo.slice();\n    return this;\n  }\n\n  /**\n   * Sets the orientation of the container.\n   * @param orientation New orientation for the container.\n   */\n  withOrientation(orientation: 'vertical' | 'horizontal'): this {\n    this._orientation = orientation;\n    return this;\n  }\n\n  /**\n   * Figures out the index of an item in the container.\n   * @param item Item whose index should be determined.\n   */\n  getItemIndex(item: DragRef): number {\n    if (!this._isDragging) {\n      return this._draggables.indexOf(item);\n    }\n\n    // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n    // The rest of the logic still stands no matter what orientation we're in, however\n    // we need to invert the array when determining the index.\n    const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n        this._itemPositions.slice().reverse() : this._itemPositions;\n\n    return findIndex(items, currentItem => currentItem.drag === item);\n  }\n\n  /**\n   * Whether the list is able to receive the item that\n   * is currently being dragged inside a connected drop list.\n   */\n  isReceiving(): boolean {\n    return this._activeSiblings.size > 0;\n  }\n\n  /**\n   * Sorts an item inside the container based on its position.\n   * @param item Item to be sorted.\n   * @param pointerX Position of the item along the X axis.\n   * @param pointerY Position of the item along the Y axis.\n   * @param pointerDelta Direction in which the pointer is moving along each axis.\n   */\n  _sortItem(item: DragRef, pointerX: number, pointerY: number,\n            pointerDelta: {x: number, y: number}): void {\n    // Don't sort the item if it's out of range.\n    if (!this._isPointerNearDropContainer(pointerX, pointerY)) {\n      return;\n    }\n\n    const siblings = this._itemPositions;\n    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n\n    if (newIndex === -1 && siblings.length > 0) {\n      return;\n    }\n\n    const isHorizontal = this._orientation === 'horizontal';\n    const currentIndex = findIndex(siblings, currentItem => currentItem.drag === item);\n    const siblingAtNewPosition = siblings[newIndex];\n    const currentPosition = siblings[currentIndex].clientRect;\n    const newPosition = siblingAtNewPosition.clientRect;\n    const delta = currentIndex > newIndex ? 1 : -1;\n\n    this._previousSwap.drag = siblingAtNewPosition.drag;\n    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n\n    // How many pixels the item's placeholder should be offset.\n    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n\n    // How many pixels all the other items should be offset.\n    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n\n    // Save the previous order of the items before moving the item to its new index.\n    // We use this to check whether an item has been moved as a result of the sorting.\n    const oldOrder = siblings.slice();\n\n    // Shuffle the array in place.\n    moveItemInArray(siblings, currentIndex, newIndex);\n\n    this.sorted.next({\n      previousIndex: currentIndex,\n      currentIndex: newIndex,\n      container: this,\n      item\n    });\n\n    siblings.forEach((sibling, index) => {\n      // Don't do anything if the position hasn't changed.\n      if (oldOrder[index] === sibling) {\n        return;\n      }\n\n      const isDraggedItem = sibling.drag === item;\n      const offset = isDraggedItem ? itemOffset : siblingOffset;\n      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                                              sibling.drag.getRootElement();\n\n      // Update the offset to reflect the new position.\n      sibling.offset += offset;\n\n      // Since we're moving the items with a `transform`, we need to adjust their cached\n      // client rects to reflect their new position, as well as swap their positions in the cache.\n      // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n      // elements may be mid-animation which will give us a wrong result.\n      if (isHorizontal) {\n        // Round the transforms since some browsers will\n        // blur the elements, for sub-pixel transforms.\n        elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n        adjustClientRect(sibling.clientRect, 0, offset);\n      } else {\n        elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n        adjustClientRect(sibling.clientRect, offset, 0);\n      }\n    });\n  }\n\n  /** Caches the position of the drop list. */\n  private _cacheOwnPosition() {\n    this._clientRect = this.element.getBoundingClientRect();\n  }\n\n  /** Refreshes the position cache of the items and sibling containers. */\n  private _cacheItemPositions() {\n    const isHorizontal = this._orientation === 'horizontal';\n\n    this._itemPositions = this._activeDraggables.map(drag => {\n      const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\n          // If the element is being dragged, we have to measure the\n          // placeholder, because the element is hidden.\n          drag.getPlaceholderElement() :\n          drag.getRootElement();\n      const clientRect = elementToMeasure.getBoundingClientRect();\n\n      return {\n        drag,\n        offset: 0,\n        // We need to clone the `clientRect` here, because all the values on it are readonly\n        // and we need to be able to update them. Also we can't use a spread here, because\n        // the values on a `ClientRect` aren't own properties. See:\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n        clientRect: {\n          top: clientRect.top,\n          right: clientRect.right,\n          bottom: clientRect.bottom,\n          left: clientRect.left,\n          width: clientRect.width,\n          height: clientRect.height\n        }\n      };\n    }).sort((a, b) => {\n      return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                            a.clientRect.top - b.clientRect.top;\n    });\n  }\n\n  /** Resets the container to its initial state. */\n  private _reset() {\n    this._isDragging = false;\n\n    // TODO(crisbeto): may have to wait for the animations to finish.\n    this._activeDraggables.forEach(item => item.getRootElement().style.transform = '');\n    this._siblings.forEach(sibling => sibling._stopReceiving(this));\n    this._activeDraggables = [];\n    this._itemPositions = [];\n    this._previousSwap.drag = null;\n    this._previousSwap.delta = 0;\n  }\n\n  /**\n   * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n   * @param currentIndex Index of the item currently being dragged.\n   * @param siblings All of the items in the list.\n   * @param delta Direction in which the user is moving.\n   */\n  private _getSiblingOffsetPx(currentIndex: number,\n                              siblings: CachedItemPosition[],\n                              delta: 1 | -1) {\n\n    const isHorizontal = this._orientation === 'horizontal';\n    const currentPosition = siblings[currentIndex].clientRect;\n    const immediateSibling = siblings[currentIndex + delta * -1];\n    let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n\n    if (immediateSibling) {\n      const start = isHorizontal ? 'left' : 'top';\n      const end = isHorizontal ? 'right' : 'bottom';\n\n      // Get the spacing between the start of the current item and the end of the one immediately\n      // after it in the direction in which the user is dragging, or vice versa. We add it to the\n      // offset in order to push the element to where it will be when it's inline and is influenced\n      // by the `margin` of its siblings.\n      if (delta === -1) {\n        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n      } else {\n        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n      }\n    }\n\n    return siblingOffset;\n  }\n\n  /**\n   * Checks whether the pointer coordinates are close to the drop container.\n   * @param pointerX Coordinates along the X axis.\n   * @param pointerY Coordinates along the Y axis.\n   */\n  private _isPointerNearDropContainer(pointerX: number, pointerY: number): boolean {\n    const {top, right, bottom, left, width, height} = this._clientRect;\n    const xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n    const yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n\n    return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n           pointerX > left - xThreshold && pointerX < right + xThreshold;\n  }\n\n  /**\n   * Gets the offset in pixels by which the item that is being dragged should be moved.\n   * @param currentPosition Current position of the item.\n   * @param newPosition Position of the item where the current item should be moved.\n   * @param delta Direction in which the user is moving.\n   */\n  private _getItemOffsetPx(currentPosition: ClientRect, newPosition: ClientRect, delta: 1 | -1) {\n    const isHorizontal = this._orientation === 'horizontal';\n    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n                                    newPosition.top - currentPosition.top;\n\n    // Account for differences in the item width/height.\n    if (delta === -1) {\n      itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                                   newPosition.height - currentPosition.height;\n    }\n\n    return itemOffset;\n  }\n\n  /**\n   * Gets the index of an item in the drop container, based on the position of the user's pointer.\n   * @param item Item that is being sorted.\n   * @param pointerX Position of the user's pointer along the X axis.\n   * @param pointerY Position of the user's pointer along the Y axis.\n   * @param delta Direction in which the user is moving their pointer.\n   */\n  private _getItemIndexFromPointerPosition(item: DragRef, pointerX: number, pointerY: number,\n                                           delta?: {x: number, y: number}) {\n    const isHorizontal = this._orientation === 'horizontal';\n\n    return findIndex(this._itemPositions, ({drag, clientRect}, _, array) => {\n      if (drag === item) {\n        // If there's only one item left in the container, it must be\n        // the dragged item itself so we use it as a reference.\n        return array.length < 2;\n      }\n\n      if (delta) {\n        const direction = isHorizontal ? delta.x : delta.y;\n\n        // If the user is still hovering over the same item as last time, and they didn't change\n        // the direction in which they're dragging, we don't consider it a direction swap.\n        if (drag === this._previousSwap.drag && direction === this._previousSwap.delta) {\n          return false;\n        }\n      }\n\n      return isHorizontal ?\n          // Round these down since most browsers report client rects with\n          // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n          pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n          pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n    });\n  }\n\n  /**\n   * Checks whether the user's pointer is positioned over the container.\n   * @param x Pointer position along the X axis.\n   * @param y Pointer position along the Y axis.\n   */\n  _isOverContainer(x: number, y: number): boolean {\n    return isInsideClientRect(this._clientRect, x, y);\n  }\n\n  /**\n   * Figures out whether an item should be moved into a sibling\n   * drop container, based on its current position.\n   * @param item Drag item that is being moved.\n   * @param x Position of the item along the X axis.\n   * @param y Position of the item along the Y axis.\n   */\n  _getSiblingContainerFromPosition(item: DragRef, x: number, y: number): DropListRef | undefined {\n    return this._siblings.find(sibling => sibling._canReceive(item, x, y));\n  }\n\n  /**\n   * Checks whether the drop list can receive the passed-in item.\n   * @param item Item that is being dragged into the list.\n   * @param x Position of the item along the X axis.\n   * @param y Position of the item along the Y axis.\n   */\n  _canReceive(item: DragRef, x: number, y: number): boolean {\n    if (!this.enterPredicate(item, this) || !isInsideClientRect(this._clientRect, x, y)) {\n      return false;\n    }\n\n    const elementFromPoint = this._document.elementFromPoint(x, y);\n\n    // If there's no element at the pointer position, then\n    // the client rect is probably scrolled out of the view.\n    if (!elementFromPoint) {\n      return false;\n    }\n\n    // The `ClientRect`, that we're using to find the container over which the user is\n    // hovering, doesn't give us any information on whether the element has been scrolled\n    // out of the view or whether it's overlapping with other containers. This means that\n    // we could end up transferring the item into a container that's invisible or is positioned\n    // below another one. We use the result from `elementFromPoint` to get the top-most element\n    // at the pointer position and to find whether it's one of the intersecting drop containers.\n    return elementFromPoint === this.element || this.element.contains(elementFromPoint);\n  }\n\n  /**\n   * Called by one of the connected drop lists when a dragging sequence has started.\n   * @param sibling Sibling in which dragging has started.\n   */\n  _startReceiving(sibling: DropListRef) {\n    const activeSiblings = this._activeSiblings;\n\n    if (!activeSiblings.has(sibling)) {\n      activeSiblings.add(sibling);\n      this._cacheOwnPosition();\n    }\n  }\n\n  /**\n   * Called by a connected drop list when dragging has stopped.\n   * @param sibling Sibling whose dragging has stopped.\n   */\n  _stopReceiving(sibling: DropListRef) {\n    this._activeSiblings.delete(sibling);\n  }\n}\n\n\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\nfunction adjustClientRect(clientRect: ClientRect, top: number, left: number) {\n  clientRect.top += top;\n  clientRect.bottom = clientRect.top + clientRect.height;\n\n  clientRect.left += left;\n  clientRect.right = clientRect.left + clientRect.width;\n}\n\n\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.find` which isn't part of the standard Google typings.\n * @param array Array in which to look for matches.\n * @param predicate Function used to determine whether an item is a match.\n */\nfunction findIndex<T>(array: T[],\n                      predicate: (value: T, index: number, obj: T[]) => boolean): number {\n\n  for (let i = 0; i < array.length; i++) {\n    if (predicate(array[i], i, array)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\nfunction isInsideClientRect(clientRect: ClientRect, x: number, y: number) {\n  const {top, bottom, left, right} = clientRect;\n  return y >= top && y <= bottom && x >= left && x <= right;\n}\n"]}