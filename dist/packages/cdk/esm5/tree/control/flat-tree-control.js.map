{"version":3,"file":"flat-tree-control.js","sourceRoot":"","sources":["../../../../../../src/cdk/tree/control/flat-tree-control.ts"],"names":[],"mappings":";;;;;;;;;;;;AAQA,OAAO,EAAC,eAAe,EAAC,MAAM,qBAAqB,CAAC;;;;;AAGpD;;;;;IAAwC,2CAAkB;IAExD,8EAA8E;IAC9E,yBAAmB,QAAiC,EACjC,YAAsC;QADzD,YAEE,iBAAO,SACR;QAHkB,cAAQ,GAAR,QAAQ,CAAyB;QACjC,kBAAY,GAAZ,YAAY,CAA0B;;IAEzD,CAAC;IAED;;;;;OAKG;;;;;;;;;IACH,wCAAc;;;;;;;;IAAd,UAAe,QAAW;;YAClB,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC;;YAC7C,OAAO,GAAQ,EAAE;QAEvB,uFAAuF;QACvF,sFAAsF;QACtF,aAAa;QACb,2FAA2F;QAC3F,sFAAsF;QACtF,0BAA0B;QAC1B,KAAK,IAAI,CAAC,GAAG,UAAU,GAAG,CAAC,EACvB,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EACvF,CAAC,EAAE,EAAE;YACP,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;SACjC;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;;;OAKG;;;;;;;;IACH,mCAAS;;;;;;;IAAT;;QACE,CAAA,KAAA,IAAI,CAAC,cAAc,CAAA,CAAC,MAAM,WAAI,IAAI,CAAC,SAAS,EAAE;IAChD,CAAC;IACH,sBAAC;AAAD,CAAC,AAzCD,CAAwC,eAAe,GAyCtD;;;;;;;;IAtCa,mCAAwC;;IACxC,uCAA6C","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BaseTreeControl} from './base-tree-control';\n\n/** Flat tree control. Able to expand/collapse a subtree recursively for flattened tree. */\nexport class FlatTreeControl<T> extends BaseTreeControl<T> {\n\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(public getLevel: (dataNode: T) => number,\n              public isExpandable: (dataNode: T) => boolean) {\n    super();\n  }\n\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode: T): T[] {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results: T[] = [];\n\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (let i = startIndex + 1;\n        i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]);\n        i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll(): void {\n    this.expansionModel.select(...this.dataNodes);\n  }\n}\n"]}