{"version":3,"file":"can-stick.js","sourceRoot":"","sources":["../../../../../src/cdk/table/can-stick.ts"],"names":[],"mappings":";;;;;;;;;;;;AAQA,OAAO,EAAC,qBAAqB,EAAC,MAAM,uBAAuB,CAAC;;;;;;;;AAW5D,8BAYC;;;;;;IAVC,0BAAgB;;;;;IAGhB,qCAA2B;;;;;IAG3B,sDAA4B;;;;;IAG5B,wDAA2B;;;;;;;;;;;AAY7B,MAAM,UAAU,mBAAmB,CAA4B,IAAO;IACpE;QAAqB,mCAAI;QAyBvB;YAAY,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YAA1B,+BAAuC,IAAI,UAAI;YAjB/C,aAAO,GAAY,KAAK,CAAC;;;;YAGzB,uBAAiB,GAAY,KAAK,CAAC;;QAcW,CAAC;QAvB/C,sBAAI,2BAAM;YADV,oDAAoD;;;;;YACpD,cAAwB,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;;;;;YAC9C,UAAW,CAAU;;oBACb,SAAS,GAAG,IAAI,CAAC,OAAO;gBAC9B,IAAI,CAAC,OAAO,GAAG,qBAAqB,CAAC,CAAC,CAAC,CAAC;gBACxC,IAAI,CAAC,iBAAiB,GAAG,SAAS,KAAK,IAAI,CAAC,OAAO,CAAC;YACtD,CAAC;;;WAL6C;QAW9C,uEAAuE;;;;;QACvE,kCAAgB;;;;QAAhB;;gBACQ,gBAAgB,GAAG,IAAI,CAAC,iBAAiB;YAC/C,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;YAC/B,OAAO,gBAAgB,CAAC;QAC1B,CAAC;QAED,8FAA8F;;;;;QAC9F,oCAAkB;;;;QAAlB;YACE,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;QACjC,CAAC;QAGH,cAAC;IAAD,CAAC,AA1BM,CAAc,IAAI,GA0BvB;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\n\n/** @docs-private */\nexport type Constructor<T> = new(...args: any[]) => T;\n\n/**\n * Interface for a mixin to provide a directive with a function that checks if the sticky input has\n * been changed since the last time the function was called. Essentially adds a dirty-check to the\n * sticky value.\n * @docs-private\n */\nexport interface CanStick {\n  /** Whether sticky positioning should be applied. */\n  sticky: boolean;\n\n  /** Whether the sticky input has changed since it was last checked. */\n  _hasStickyChanged: boolean;\n\n  /** Whether the sticky value has changed since this was last called. */\n  hasStickyChanged(): boolean;\n\n  /** Resets the dirty check for cases where the sticky state has been used without checking. */\n  resetStickyChanged(): void;\n}\n\n/** @docs-private */\nexport type CanStickCtor = Constructor<CanStick>;\n\n/**\n * Mixin to provide a directive with a function that checks if the sticky input has been\n * changed since the last time the function was called. Essentially adds a dirty-check to the\n * sticky value.\n * @docs-private\n */\nexport function mixinHasStickyInput<T extends Constructor<{}>>(base: T): CanStickCtor & T {\n  return class extends base {\n    /** Whether sticky positioning should be applied. */\n    get sticky(): boolean { return this._sticky; }\n    set sticky(v: boolean) {\n      const prevValue = this._sticky;\n      this._sticky = coerceBooleanProperty(v);\n      this._hasStickyChanged = prevValue !== this._sticky;\n    }\n    _sticky: boolean = false;\n\n    /** Whether the sticky input has changed since it was last checked. */\n    _hasStickyChanged: boolean = false;\n\n    /** Whether the sticky value has changed since this was last called. */\n    hasStickyChanged(): boolean {\n      const hasStickyChanged = this._hasStickyChanged;\n      this._hasStickyChanged = false;\n      return hasStickyChanged;\n    }\n\n    /** Resets the dirty check for cases where the sticky state has been used without checking. */\n    resetStickyChanged() {\n      this._hasStickyChanged = false;\n    }\n\n    constructor(...args: any[]) { super(...args); }\n  };\n}\n"]}