{"version":3,"file":"auto-size-virtual-scroll.js","sourceRoot":"","sources":["../../../../src/cdk-experimental/scrolling/auto-size-virtual-scroll.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;;;;;;;;;;AAEH,kDAA2D;AAE3D,oDAIgC;AAChC,sCAAsE;AACtE,6BAAgC;AAGhC;;;GAGG;AACH;IAUE,0FAA0F;IAC1F,0BAAY,eAAoB;QAApB,gCAAA,EAAA,oBAAoB;QAVhC,6DAA6D;QACrD,iBAAY,GAAG,CAAC,CAAC;QAUvB,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;QACxC,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC1C,CAAC;IAED,qCAAqC;IACrC,6CAAkB,GAAlB;QACE,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED;;;;OAIG;IACH,oCAAS,GAAT,UAAU,KAAgB,EAAE,IAAY;QACtC,IAAM,cAAc,GAAG,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC;QACnE,IAAI,cAAc,EAAE;YAClB,IAAM,kBAAkB,GACpB,CAAC,IAAI,GAAG,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,cAAc,CAAC;YACxE,IAAI,kBAAkB,EAAE;gBACtB,IAAI,CAAC,gBAAgB,GAAG,kBAAkB,CAAC;gBAC3C,IAAI,CAAC,YAAY,GAAG,cAAc,CAAC;aACpC;SACF;IACH,CAAC;IAED,2BAA2B;IAC3B,gCAAK,GAAL;QACE,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9C,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;IACxB,CAAC;IACH,uBAAC;AAAD,CAAC,AA3CD,IA2CC;AA3CY,4CAAgB;AA8C7B,kFAAkF;AAClF;IAoCE;;;;;;;OAOG;IACH,uCAAY,WAAmB,EAAE,WAAmB,EAAE,QAAiC;QAAjC,yBAAA,EAAA,eAAe,gBAAgB,EAAE;QA3CvF,kEAAkE;QAClE,wBAAmB,GAAG,IAAI,iBAAU,CAAS;YAC3C,6BAA6B;YAC7B,MAAM,KAAK,CAAC,4EAA4E;gBACpF,2BAA2B,CAAC,CAAC;QACnC,CAAC,CAAC,CAAC;QAEH,6BAA6B;QACrB,cAAS,GAAoC,IAAI,CAAC;QAoB1D;;;;WAIG;QACK,qBAAgB,GAAG,CAAC,CAAC;QAW3B,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED;;;OAGG;IACH,8CAAM,GAAN,UAAO,QAAkC;QACvC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;QACvB,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,8BAA8B,EAAE,CAAC;IACxC,CAAC;IAED,0EAA0E;IAC1E,8CAAM,GAAN;QACE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED,kEAAkE;IAClE,yDAAiB,GAAjB;QACE,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,CAAC,iCAAiC,EAAE,CAAC;SAC1C;IACH,CAAC;IAED,kEAAkE;IAClE,2DAAmB,GAAnB;QACE,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,CAAC,8BAA8B,EAAE,CAAC;YACtC,IAAI,CAAC,yBAAyB,EAAE,CAAC;SAClC;IACH,CAAC;IAED,kEAAkE;IAClE,yDAAiB,GAAjB;QACE,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,CAAC,yBAAyB,EAAE,CAAC;SAClC;IACH,CAAC;IAED,kEAAkE;IAClE,+DAAuB,GAAvB;QACE,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,CAAC,2BAA2B,EAAE,CAAC;SACpC;IACH,CAAC;IAED,gDAAgD;IAChD,qDAAa,GAAb;QACE,6BAA6B;QAC7B,MAAM,KAAK,CAAC,+EAA+E;cACrF,kBAAkB,CAAC,CAAC;IAC5B,CAAC;IAED;;;;;OAKG;IACH,wDAAgB,GAAhB,UAAiB,WAAmB,EAAE,WAAmB;QACvD,IAAI,WAAW,GAAG,WAAW,EAAE;YAC7B,MAAK,CAAC,8EAA8E,CAAC,CAAC;SACvF;QACD,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;IAClC,CAAC;IAED,0DAA0D;IAClD,yEAAiC,GAAzC;QACE,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAU,CAAC;QAEjC,6BAA6B;QAC7B,IAAM,YAAY,GAAG,QAAQ,CAAC,mBAAmB,EAAE,CAAC;QACpD,yFAAyF;QACzF,IAAI,WAAW,GAAG,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC;QACxD,qCAAqC;QACrC,IAAI,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAE5C,gCAAgC;QAChC,IAAM,aAAa,GAAG,QAAQ,CAAC,gBAAgB,EAAE,CAAC;QAElD,+FAA+F;QAC/F,6FAA6F;QAC7F,kDAAkD;QAClD,IAAI,gBAAgB,GAAG,CAAC,CAAC;QACzB,IAAI,WAAW,GAAG,CAAC,EAAE;YACnB,qEAAqE;YACrE,IAAM,eAAe,GAAG,aAAa,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;YAClF,2FAA2F;YAC3F,4FAA4F;YAC5F,2BAA2B;YAC3B,0EAA0E;YAC1E,mFAAmF;YACnF,sFAAsF;YACtF,IAAM,gBAAgB,GAAG,eAAe,GAAG,IAAI,CAAC,0BAA0B,CAAC;YAC3E,uFAAuF;YACvF,4FAA4F;YAC5F,0BAA0B;YAC1B,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB;gBAC1C,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,eAAe,GAAG,CAAC,YAAY,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;YAElF,uFAAuF;YACvF,mFAAmF;YACnF,WAAW,GAAG,WAAW,GAAG,gBAAgB,CAAC;YAC7C,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;SACzC;QAED,+DAA+D;QAC/D,IAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,0BAA0B,CAAC;QAC7E,6DAA6D;QAC7D,IAAM,SAAS,GAAG,CAAC,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,wBAAwB,CAAC;YAC/E,CAAC,IAAI,CAAC,iBAAiB,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC,CAAC;QAC1D,8FAA8F;QAC9F,8CAA8C;QAC9C,IAAM,SAAS,GAAG,eAAe,GAAG,IAAI,CAAC,YAAY;YACjD,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAEhD,+EAA+E;QAC/E,IAAI,SAAS,GAAG,CAAC,EAAE;YACjB,yFAAyF;YACzF,0FAA0F;YAC1F,2FAA2F;YAC3F,2FAA2F;YAC3F,qDAAqD;YACrD,IAAI,eAAe,IAAI,QAAQ,CAAC,eAAe,EAAE,EAAE;gBACjD,IAAI,CAAC,8BAA8B,EAAE,CAAC;aACvC;iBAAM;gBACL,2FAA2F;gBAC3F,qFAAqF;gBACrF,2FAA2F;gBAC3F,IAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,SAAS,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;oBACtF,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC,CAAC,CAAC;gBAC1C,wFAAwF;gBACxF,aAAa;gBACb,IAAM,QAAQ,GAAG,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,YAAY;oBAC5E,eAAe,CAAC;gBACpB,0FAA0F;gBAC1F,4FAA4F;gBAC5F,UAAU;gBACV,IAAM,oBAAoB,GAAG,IAAI,CAAC,KAAK,CACnC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,GAAG,CAAC,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClF,IAAM,WAAW,GACb,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,GAAG,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,oBAAoB,CAAC,CAAC,CAAC;gBAEzF,2FAA2F;gBAC3F,0FAA0F;gBAC1F,iBAAiB;gBACjB,IAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAC3B,aAAa,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnF,IAAI,WAAW,GAAG,CAAC,EAAE;oBACnB,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC,GAAG,GAAG,WAAW,CAAC,CAAC;iBAChE;qBAAM;oBACL,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE,KAAK,CAAC,KAAK,GAAG,WAAW,CAAC,CAAC;iBAClE;gBAED,0FAA0F;gBAC1F,sFAAsF;gBACtF,2FAA2F;gBAC3F,2DAA2D;gBAC3D,IAAI,aAAa,SAAQ,CAAC;gBAC1B,IAAI,eAAe,SAAuB,CAAC;gBAC3C,IAAI,WAAW,GAAG,CAAC,EAAE;oBACnB,IAAI,WAAW,GAAG,QAAQ,CAAC,gBAAgB,CAAC;wBAC1C,KAAK,EAAE,KAAK,CAAC,GAAG;wBAChB,GAAG,EAAE,aAAa,CAAC,GAAG;qBACvB,CAAC,CAAC;oBACH,0CAA0C;oBAC1C,IAAI,WAAW,IAAI,QAAQ,EAAE;wBAC3B,aAAa;4BACT,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,wBAAwB,GAAG,WAAW,CAAC;wBAClF,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;qBAC3B;yBAAM;wBACL,uFAAuF;wBACvF,kEAAkE;wBAClE,KAAK,CAAC,GAAG,GAAG,aAAa,CAAC,GAAG,CAAC;wBAC9B,aAAa,GAAG,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,wBAAwB,CAAC;wBAChF,IAAI,CAAC,gBAAgB,EAAE,CAAC;qBACzB;oBACD,eAAe,GAAG,QAAQ,CAAC;iBAC5B;qBAAM;oBACL,IAAM,WAAW,GAAG,QAAQ,CAAC,gBAAgB,CAAC;wBAC5C,KAAK,EAAE,aAAa,CAAC,KAAK;wBAC1B,GAAG,EAAE,KAAK,CAAC,KAAK;qBACjB,CAAC,CAAC;oBACH,0CAA0C;oBAC1C,IAAI,WAAW,IAAI,QAAQ,EAAE;wBAC3B,aAAa,GAAG,IAAI,CAAC,0BAA0B,GAAG,WAAW,CAAC;wBAC9D,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;qBAC3B;yBAAM;wBACL,uFAAuF;wBACvF,kEAAkE;wBAClE,KAAK,CAAC,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC;wBAClC,aAAa,GAAG,IAAI,CAAC,0BAA0B,CAAC;wBAChD,IAAI,CAAC,gBAAgB,EAAE,CAAC;qBACzB;oBACD,eAAe,GAAG,UAAU,CAAC;iBAC9B;gBAED,gDAAgD;gBAChD,QAAQ,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;gBACjC,QAAQ,CAAC,wBAAwB,CAAC,aAAa,GAAG,gBAAgB,EAAE,eAAe,CAAC,CAAC;aACtF;SACF;aAAM,IAAI,gBAAgB,EAAE;YAC3B,8FAA8F;YAC9F,gFAAgF;YAChF,QAAQ,CAAC,wBAAwB,CAAC,IAAI,CAAC,0BAA0B,GAAG,gBAAgB,CAAC,CAAC;SACvF;QAED,mFAAmF;QACnF,IAAI,CAAC,iBAAiB,GAAG,YAAY,CAAC;IACxC,CAAC;IAED;;;OAGG;IACK,iEAAyB,GAAjC;QACE,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAU,CAAC;QACjC,IAAI,CAAC,wBAAwB,GAAG,QAAQ,CAAC,0BAA0B,EAAE,CAAC;QACtE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAC,gBAAgB,EAAE,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC;QACrF,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;IAC9D,CAAC;IAED,sFAAsF;IAC9E,mEAA2B,GAAnC;QACE,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAU,CAAC;QACjC,IAAI,CAAC,0BAA0B,GAAG,QAAQ,CAAC,+BAA+B,EAAG,CAAC;IAChF,CAAC;IAED;;;OAGG;IACK,sEAA8B,GAAtC;QACE,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAU,CAAC;QACjC,IAAM,YAAY,GAAG,QAAQ,CAAC,mBAAmB,EAAE,CAAC;QACpD,IAAI,CAAC,iBAAiB,GAAG,YAAY,CAAC;QACtC,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAE1B,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;QACrD,IAAM,iBAAiB,GACnB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,aAAa,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC;QAChF,IAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,CAAC;QAC3D,IAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAC3B,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QAE9E,QAAQ,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QACjC,QAAQ,CAAC,wBAAwB,CAAC,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;IAC5D,CAAC;IAED,+EAA+E;IAC/E;;;;;;;OAOG;IACK,gEAAwB,GAAhC,UAAiC,UAAkB;QACjD,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAU,CAAC;QACjC,IAAM,KAAK,GAAc;YACvB,KAAK,EAAE,UAAU;YACjB,GAAG,EAAE,UAAU;gBACX,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;SAChF,CAAC;QACF,IAAM,KAAK,GAAG,KAAK,CAAC,GAAG,GAAG,QAAQ,CAAC,aAAa,EAAE,CAAC;QACnD,IAAI,KAAK,GAAG,CAAC,EAAE;YACb,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;SAChD;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED,+EAA+E;IAC/E;;;;;;;OAOG;IACK,oDAAY,GAApB,UAAqB,KAAgB,EAAE,WAAmB,EAAE,SAAiB;QAC3E,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAU,CAAC;QACjC,IAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,GAAG,WAAW,CAAC,CAAC;QACrD,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,aAAa,EAAE,EAAE,KAAK,CAAC,GAAG,GAAG,SAAS,CAAC,CAAC;QACtE,OAAO,EAAC,KAAK,OAAA,EAAE,GAAG,KAAA,EAAC,CAAC;IACtB,CAAC;IAED,gDAAgD;IACxC,+DAAuB,GAA/B,UAAgC,mBAA2B;QACzD,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAU,CAAC;QACjC,IAAM,aAAa,GAAG,QAAQ,CAAC,gBAAgB,EAAE,CAAC;QAClD,IAAM,SAAS,GAAG,mBAAmB;YACjC,CAAC,QAAQ,CAAC,aAAa,EAAE,GAAG,CAAC,aAAa,CAAC,GAAG,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;gBACtE,IAAI,CAAC,SAAS,CAAC,kBAAkB,EAAE,CAAC;QACxC,QAAQ,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;IAC1C,CAAC;IACH,oCAAC;AAAD,CAAC,AA1VD,IA0VC;AA1VY,sEAA6B;AA4V1C;;;;;GAKG;AACH,SAAgB,qCAAqC,CAAC,WAAqC;IACzF,OAAO,WAAW,CAAC,eAAe,CAAC;AACrC,CAAC;AAFD,sFAEC;AAGD,6EAA6E;AAS7E;IARA;QAgBE,iBAAY,GAAG,GAAG,CAAC;QAWnB,iBAAY,GAAG,GAAG,CAAC;QAEnB,kDAAkD;QAClD,oBAAe,GAAG,IAAI,6BAA6B,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IAK1F,CAAC;iCA3BY,wBAAwB;IAMnC,sBAAI,iDAAW;QALf;;;WAGG;aAEH,cAA4B,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;aACvD,UAAgB,KAAa,IAAI,IAAI,CAAC,YAAY,GAAG,+BAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;;;OAD5B;IAWvD,sBAAI,iDAAW;QAPf;;;;;WAKG;aAEH,cAA4B,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;aACvD,UAAgB,KAAa,IAAI,IAAI,CAAC,YAAY,GAAG,+BAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;;;OAD5B;IAOvD,8CAAW,GAAX;QACE,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;IAC5E,CAAC;;IApBD;QADC,YAAK,EAAE;;;+DAC+C;IAWvD;QADC,YAAK,EAAE;;;+DAC+C;IAjB5C,wBAAwB;QARpC,gBAAS,CAAC;YACT,QAAQ,EAAE,uCAAuC;YACjD,SAAS,EAAE,CAAC;oBACV,OAAO,EAAE,mCAAuB;oBAChC,UAAU,EAAE,qCAAqC;oBACjD,IAAI,EAAE,CAAC,iBAAU,CAAC,cAAM,OAAA,0BAAwB,EAAxB,CAAwB,CAAC,CAAC;iBACnD,CAAC;SACH,CAAC;OACW,wBAAwB,CA2BpC;IAAD,+BAAC;CAAA,AA3BD,IA2BC;AA3BY,4DAAwB","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {ListRange} from '@angular/cdk/collections';\nimport {\n  CdkVirtualScrollViewport,\n  VIRTUAL_SCROLL_STRATEGY,\n  VirtualScrollStrategy\n} from '@angular/cdk/scrolling';\nimport {Directive, forwardRef, Input, OnChanges} from '@angular/core';\nimport {Observable} from 'rxjs';\n\n\n/**\n * A class that tracks the size of items that have been seen and uses it to estimate the average\n * item size.\n */\nexport class ItemSizeAverager {\n  /** The total amount of weight behind the current average. */\n  private _totalWeight = 0;\n\n  /** The current average item size. */\n  private _averageItemSize: number;\n\n  /** The default size to use for items when no data is available. */\n  private _defaultItemSize: number;\n\n  /** @param defaultItemSize The default size to use for items when no data is available. */\n  constructor(defaultItemSize = 50) {\n    this._defaultItemSize = defaultItemSize;\n    this._averageItemSize = defaultItemSize;\n  }\n\n  /** Returns the average item size. */\n  getAverageItemSize(): number {\n    return this._averageItemSize;\n  }\n\n  /**\n   * Adds a measurement sample for the estimator to consider.\n   * @param range The measured range.\n   * @param size The measured size of the given range in pixels.\n   */\n  addSample(range: ListRange, size: number) {\n    const newTotalWeight = this._totalWeight + range.end - range.start;\n    if (newTotalWeight) {\n      const newAverageItemSize =\n          (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\n      if (newAverageItemSize) {\n        this._averageItemSize = newAverageItemSize;\n        this._totalWeight = newTotalWeight;\n      }\n    }\n  }\n\n  /** Resets the averager. */\n  reset() {\n    this._averageItemSize = this._defaultItemSize;\n    this._totalWeight = 0;\n  }\n}\n\n\n/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\nexport class AutoSizeVirtualScrollStrategy implements VirtualScrollStrategy {\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  scrolledIndexChange = new Observable<number>(() => {\n    // TODO(mmalerba): Implement.\n    throw Error('cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' +\n        ' autosize scroll strategy');\n  });\n\n  /** The attached viewport. */\n  private _viewport: CdkVirtualScrollViewport | null = null;\n\n  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n  private _minBufferPx: number;\n\n  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n  private _maxBufferPx: number;\n\n  /** The estimator used to estimate the size of unseen items. */\n  private _averager: ItemSizeAverager;\n\n  /** The last measured scroll offset of the viewport. */\n  private _lastScrollOffset: number;\n\n  /** The last measured size of the rendered content in the viewport. */\n  private _lastRenderedContentSize: number;\n\n  /** The last measured size of the rendered content in the viewport. */\n  private _lastRenderedContentOffset: number;\n\n  /**\n   * The number of consecutive cycles where removing extra items has failed. Failure here means that\n   * we estimated how many items we could safely remove, but our estimate turned out to be too much\n   * and it wasn't safe to remove that many elements.\n   */\n  private _removalFailures = 0;\n\n  /**\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n   *     If the amount of buffer dips below this number, more items will be rendered.\n   * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n   *     If the actual amount turns out to be less it will not necessarily trigger an additional\n   *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n   * @param averager The averager used to estimate the size of unseen items.\n   */\n  constructor(minBufferPx: number, maxBufferPx: number, averager = new ItemSizeAverager()) {\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n    this._averager = averager;\n  }\n\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport: CdkVirtualScrollViewport) {\n    this._averager.reset();\n    this._viewport = viewport;\n    this._renderContentForCurrentOffset();\n  }\n\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach() {\n    this._viewport = null;\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentScrolled() {\n    if (this._viewport) {\n      this._updateRenderedContentAfterScroll();\n    }\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onDataLengthChanged() {\n    if (this._viewport) {\n      this._renderContentForCurrentOffset();\n      this._checkRenderedContentSize();\n    }\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentRendered() {\n    if (this._viewport) {\n      this._checkRenderedContentSize();\n    }\n  }\n\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onRenderedOffsetChanged() {\n    if (this._viewport) {\n      this._checkRenderedContentOffset();\n    }\n  }\n\n  /** Scroll to the offset for the given index. */\n  scrollToIndex(): void {\n    // TODO(mmalerba): Implement.\n    throw Error('cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize'\n        + ' scroll strategy');\n  }\n\n  /**\n   * Update the buffer parameters.\n   * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n   *     pixels).\n   */\n  updateBufferSize(minBufferPx: number, maxBufferPx: number) {\n    if (maxBufferPx < minBufferPx) {\n      throw('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n    }\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n  }\n\n  /** Update the rendered content after the user scrolls. */\n  private _updateRenderedContentAfterScroll() {\n    const viewport = this._viewport!;\n\n    // The current scroll offset.\n    const scrollOffset = viewport.measureScrollOffset();\n    // The delta between the current scroll offset and the previously recorded scroll offset.\n    let scrollDelta = scrollOffset - this._lastScrollOffset;\n    // The magnitude of the scroll delta.\n    let scrollMagnitude = Math.abs(scrollDelta);\n\n    // The currently rendered range.\n    const renderedRange = viewport.getRenderedRange();\n\n    // If we're scrolling toward the top, we need to account for the fact that the predicted amount\n    // of content and the actual amount of scrollable space may differ. We address this by slowly\n    // correcting the difference on each scroll event.\n    let offsetCorrection = 0;\n    if (scrollDelta < 0) {\n      // The content offset we would expect based on the average item size.\n      const predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\n      // The difference between the predicted size of the unrendered content at the beginning and\n      // the actual available space to scroll over. We need to reduce this to zero by the time the\n      // user scrolls to the top.\n      // - 0 indicates that the predicted size and available space are the same.\n      // - A negative number that the predicted size is smaller than the available space.\n      // - A positive number indicates the predicted size is larger than the available space\n      const offsetDifference = predictedOffset - this._lastRenderedContentOffset;\n      // The amount of difference to correct during this scroll event. We calculate this as a\n      // percentage of the total difference based on the percentage of the distance toward the top\n      // that the user scrolled.\n      offsetCorrection = Math.round(offsetDifference *\n          Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))));\n\n      // Based on the offset correction above, we pretend that the scroll delta was bigger or\n      // smaller than it actually was, this way we can start to eliminate the difference.\n      scrollDelta = scrollDelta - offsetCorrection;\n      scrollMagnitude = Math.abs(scrollDelta);\n    }\n\n    // The current amount of buffer past the start of the viewport.\n    const startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\n    // The current amount of buffer past the end of the viewport.\n    const endBuffer = (this._lastRenderedContentOffset + this._lastRenderedContentSize) -\n        (this._lastScrollOffset + viewport.getViewportSize());\n    // The amount of unfilled space that should be filled on the side the user is scrolling toward\n    // in order to safely absorb the scroll delta.\n    const underscan = scrollMagnitude + this._minBufferPx -\n        (scrollDelta < 0 ? startBuffer : endBuffer);\n\n    // Check if there's unfilled space that we need to render new elements to fill.\n    if (underscan > 0) {\n      // Check if the scroll magnitude was larger than the viewport size. In this case the user\n      // won't notice a discontinuity if we just jump to the new estimated position in the list.\n      // However, if the scroll magnitude is smaller than the viewport the user might notice some\n      // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\n      // the same number of pixels as the scroll magnitude.\n      if (scrollMagnitude >= viewport.getViewportSize()) {\n        this._renderContentForCurrentOffset();\n      } else {\n        // The number of new items to render on the side the user is scrolling towards. Rather than\n        // just filling the underscan space, we actually fill enough to have a buffer size of\n        // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\n        const addItems = Math.max(0, Math.ceil((underscan - this._minBufferPx + this._maxBufferPx) /\n            this._averager.getAverageItemSize()));\n        // The amount of filled space beyond what is necessary on the side the user is scrolling\n        // away from.\n        const overscan = (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx +\n            scrollMagnitude;\n        // The number of currently rendered items to remove on the side the user is scrolling away\n        // from. If removal has failed in recent cycles we are less aggressive in how much we try to\n        // remove.\n        const unboundedRemoveItems = Math.floor(\n            overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1));\n        const removeItems =\n            Math.min(renderedRange.end - renderedRange.start, Math.max(0, unboundedRemoveItems));\n\n        // The new range we will tell the viewport to render. We first expand it to include the new\n        // items we want rendered, we then contract the opposite side to remove items we no longer\n        // want rendered.\n        const range = this._expandRange(\n            renderedRange, scrollDelta < 0 ? addItems : 0, scrollDelta > 0 ? addItems : 0);\n        if (scrollDelta < 0) {\n          range.end = Math.max(range.start + 1, range.end - removeItems);\n        } else {\n          range.start = Math.min(range.end - 1, range.start + removeItems);\n        }\n\n        // The new offset we want to set on the rendered content. To determine this we measure the\n        // number of pixels we removed and then adjust the offset to the start of the rendered\n        // content or to the end of the rendered content accordingly (whichever one doesn't require\n        // that the newly added items to be rendered to calculate.)\n        let contentOffset: number;\n        let contentOffsetTo: 'to-start' | 'to-end';\n        if (scrollDelta < 0) {\n          let removedSize = viewport.measureRangeSize({\n            start: range.end,\n            end: renderedRange.end,\n          });\n          // Check that we're not removing too much.\n          if (removedSize <= overscan) {\n            contentOffset =\n                this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\n            this._removalFailures = 0;\n          } else {\n            // If the removal is more than the overscan can absorb just undo it and record the fact\n            // that the removal failed so we can be less aggressive next time.\n            range.end = renderedRange.end;\n            contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\n            this._removalFailures++;\n          }\n          contentOffsetTo = 'to-end';\n        } else {\n          const removedSize = viewport.measureRangeSize({\n            start: renderedRange.start,\n            end: range.start,\n          });\n          // Check that we're not removing too much.\n          if (removedSize <= overscan) {\n            contentOffset = this._lastRenderedContentOffset + removedSize;\n            this._removalFailures = 0;\n          } else {\n            // If the removal is more than the overscan can absorb just undo it and record the fact\n            // that the removal failed so we can be less aggressive next time.\n            range.start = renderedRange.start;\n            contentOffset = this._lastRenderedContentOffset;\n            this._removalFailures++;\n          }\n          contentOffsetTo = 'to-start';\n        }\n\n        // Set the range and offset we calculated above.\n        viewport.setRenderedRange(range);\n        viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\n      }\n    } else if (offsetCorrection) {\n      // Even if the rendered range didn't change, we may still need to adjust the content offset to\n      // simulate scrolling slightly slower or faster than the user actually scrolled.\n      viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\n    }\n\n    // Save the scroll offset to be compared to the new value on the next scroll event.\n    this._lastScrollOffset = scrollOffset;\n  }\n\n  /**\n   * Checks the size of the currently rendered content and uses it to update the estimated item size\n   * and estimated total content size.\n   */\n  private _checkRenderedContentSize() {\n    const viewport = this._viewport!;\n    this._lastRenderedContentSize = viewport.measureRenderedContentSize();\n    this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\n    this._updateTotalContentSize(this._lastRenderedContentSize);\n  }\n\n  /** Checks the currently rendered content offset and saves the value for later use. */\n  private _checkRenderedContentOffset() {\n    const viewport = this._viewport!;\n    this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart()!;\n  }\n\n  /**\n   * Recalculates the rendered content based on our estimate of what should be shown at the current\n   * scroll offset.\n   */\n  private _renderContentForCurrentOffset() {\n    const viewport = this._viewport!;\n    const scrollOffset = viewport.measureScrollOffset();\n    this._lastScrollOffset = scrollOffset;\n    this._removalFailures = 0;\n\n    const itemSize = this._averager.getAverageItemSize();\n    const firstVisibleIndex =\n        Math.min(viewport.getDataLength() - 1, Math.floor(scrollOffset / itemSize));\n    const bufferSize = Math.ceil(this._maxBufferPx / itemSize);\n    const range = this._expandRange(\n        this._getVisibleRangeForIndex(firstVisibleIndex), bufferSize, bufferSize);\n\n    viewport.setRenderedRange(range);\n    viewport.setRenderedContentOffset(itemSize * range.start);\n  }\n\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\n  /**\n   * Gets the visible range of data for the given start index. If the start index is too close to\n   * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n   * fill the viewport.\n   * Note: must not be called if `this._viewport` is null\n   * @param startIndex The index to start the range at\n   * @return a range estimated to be large enough to fill the viewport when rendered.\n   */\n  private _getVisibleRangeForIndex(startIndex: number): ListRange {\n    const viewport = this._viewport!;\n    const range: ListRange = {\n      start: startIndex,\n      end: startIndex +\n          Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize())\n    };\n    const extra = range.end - viewport.getDataLength();\n    if (extra > 0) {\n      range.start = Math.max(0, range.start - extra);\n    }\n    return range;\n  }\n\n  // TODO: maybe move to base class, can probably share with fixed size strategy.\n  /**\n   * Expand the given range by the given amount in either direction.\n   * Note: must not be called if `this._viewport` is null\n   * @param range The range to expand\n   * @param expandStart The number of items to expand the start of the range by.\n   * @param expandEnd The number of items to expand the end of the range by.\n   * @return The expanded range.\n   */\n  private _expandRange(range: ListRange, expandStart: number, expandEnd: number): ListRange {\n    const viewport = this._viewport!;\n    const start = Math.max(0, range.start - expandStart);\n    const end = Math.min(viewport.getDataLength(), range.end + expandEnd);\n    return {start, end};\n  }\n\n  /** Update the viewport's total content size. */\n  private _updateTotalContentSize(renderedContentSize: number) {\n    const viewport = this._viewport!;\n    const renderedRange = viewport.getRenderedRange();\n    const totalSize = renderedContentSize +\n        (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) *\n        this._averager.getAverageItemSize();\n    viewport.setTotalContentSize(totalSize);\n  }\n}\n\n/**\n * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n * `AutoSizeVirtualScrollStrategy` from the given directive.\n * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n *     `AutoSizeVirtualScrollStrategy` from.\n */\nexport function _autoSizeVirtualScrollStrategyFactory(autoSizeDir: CdkAutoSizeVirtualScroll) {\n  return autoSizeDir._scrollStrategy;\n}\n\n\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\n@Directive({\n  selector: 'cdk-virtual-scroll-viewport[autosize]',\n  providers: [{\n    provide: VIRTUAL_SCROLL_STRATEGY,\n    useFactory: _autoSizeVirtualScrollStrategyFactory,\n    deps: [forwardRef(() => CdkAutoSizeVirtualScroll)],\n  }],\n})\nexport class CdkAutoSizeVirtualScroll implements OnChanges {\n  /**\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n   */\n  @Input()\n  get minBufferPx(): number { return this._minBufferPx; }\n  set minBufferPx(value: number) { this._minBufferPx = coerceNumberProperty(value); }\n  _minBufferPx = 100;\n\n  /**\n   * The number of pixels worth of buffer to shoot for when rendering new items.\n   * If the actual amount turns out to be less it will not necessarily trigger an additional\n   * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n   * Defaults to 200px.\n   */\n  @Input()\n  get maxBufferPx(): number { return this._maxBufferPx; }\n  set maxBufferPx(value: number) { this._maxBufferPx = coerceNumberProperty(value); }\n  _maxBufferPx = 200;\n\n  /** The scroll strategy used by this directive. */\n  _scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\n\n  ngOnChanges() {\n    this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\n  }\n}\n"]}