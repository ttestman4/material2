{"version":3,"file":"ripple-renderer.js","sourceRoot":"","sources":["../../../../../src/lib/core/ripple/ripple-renderer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ElementRef, NgZone} from '@angular/core';\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\nimport {isFakeMousedownFromScreenReader} from '@angular/cdk/a11y';\nimport {RippleRef, RippleState} from './ripple-ref';\n\nexport type RippleConfig = {\n  color?: string;\n  centered?: boolean;\n  radius?: number;\n  persistent?: boolean;\n  animation?: RippleAnimationConfig;\n  terminateOnPointerUp?: boolean;\n};\n\n/**\n * Interface that describes the configuration for the animation of a ripple.\n * There are two animation phases with different durations for the ripples.\n */\nexport interface RippleAnimationConfig {\n  /** Duration in milliseconds for the enter animation (expansion from point of contact). */\n  enterDuration?: number;\n  /** Duration in milliseconds for the exit animation (fade-out). */\n  exitDuration?: number;\n}\n\n/**\n * Interface that describes the target for launching ripples.\n * It defines the ripple configuration and disabled state for interaction ripples.\n * @docs-private\n */\nexport interface RippleTarget {\n  /** Configuration for ripples that are launched on pointer down. */\n  rippleConfig: RippleConfig;\n  /** Whether ripples on pointer down should be disabled. */\n  rippleDisabled: boolean;\n}\n\n/**\n * Default ripple animation configuration for ripples without an explicit\n * animation config specified.\n */\nexport const defaultRippleAnimationConfig = {\n  enterDuration: 450,\n  exitDuration: 400\n};\n\n/**\n * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch\n * events to avoid synthetic mouse events.\n */\nconst ignoreMouseEventsTimeout = 800;\n\n/** Options that apply to all the event listeners that are bound by the ripple renderer. */\nconst passiveEventOptions = normalizePassiveListenerOptions({passive: true});\n\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * @docs-private\n */\nexport class RippleRenderer {\n  /** Element where the ripples are being added to. */\n  private _containerElement: HTMLElement;\n\n  /** Element which triggers the ripple elements on mouse events. */\n  private _triggerElement: HTMLElement | null;\n\n  /** Whether the pointer is currently down or not. */\n  private _isPointerDown = false;\n\n  /** Events to be registered on the trigger element. */\n  private _triggerEvents = new Map<string, any>();\n\n  /** Set of currently active ripple references. */\n  private _activeRipples = new Set<RippleRef>();\n\n  /** Latest non-persistent ripple that was triggered. */\n  private _mostRecentTransientRipple: RippleRef | null;\n\n  /** Time in milliseconds when the last touchstart event happened. */\n  private _lastTouchStartEvent: number;\n\n  /**\n   * Cached dimensions of the ripple container. Set when the first\n   * ripple is shown and cleared once no more ripples are visible.\n   */\n  private _containerRect: ClientRect | null;\n\n  constructor(private _target: RippleTarget,\n              private _ngZone: NgZone,\n              elementRef: ElementRef<HTMLElement>,\n              platform: Platform) {\n\n    // Only do anything if we're on the browser.\n    if (platform.isBrowser) {\n      this._containerElement = elementRef.nativeElement;\n\n      // Specify events which need to be registered on the trigger.\n      this._triggerEvents\n        .set('mousedown', this.onMousedown)\n        .set('mouseup', this.onPointerUp)\n        .set('mouseleave', this.onPointerUp)\n\n        .set('touchstart', this.onTouchStart)\n        .set('touchend', this.onPointerUp)\n        .set('touchcancel', this.onPointerUp);\n    }\n  }\n\n  /**\n   * Fades in a ripple at the given coordinates.\n   * @param x Coordinate within the element, along the X axis at which to start the ripple.\n   * @param y Coordinate within the element, along the Y axis at which to start the ripple.\n   * @param config Extra ripple options.\n   */\n  fadeInRipple(x: number, y: number, config: RippleConfig = {}): RippleRef {\n    const containerRect = this._containerRect =\n                          this._containerRect || this._containerElement.getBoundingClientRect();\n    const animationConfig = {...defaultRippleAnimationConfig, ...config.animation};\n\n    if (config.centered) {\n      x = containerRect.left + containerRect.width / 2;\n      y = containerRect.top + containerRect.height / 2;\n    }\n\n    const radius = config.radius || distanceToFurthestCorner(x, y, containerRect);\n    const offsetX = x - containerRect.left;\n    const offsetY = y - containerRect.top;\n    const duration = animationConfig.enterDuration;\n\n    const ripple = document.createElement('div');\n    ripple.classList.add('mat-ripple-element');\n\n    ripple.style.left = `${offsetX - radius}px`;\n    ripple.style.top = `${offsetY - radius}px`;\n    ripple.style.height = `${radius * 2}px`;\n    ripple.style.width = `${radius * 2}px`;\n\n    // If the color is not set, the default CSS color will be used.\n    ripple.style.backgroundColor = config.color || null;\n    ripple.style.transitionDuration = `${duration}ms`;\n\n    this._containerElement.appendChild(ripple);\n\n    // By default the browser does not recalculate the styles of dynamically created\n    // ripple elements. This is critical because then the `scale` would not animate properly.\n    enforceStyleRecalculation(ripple);\n\n    ripple.style.transform = 'scale(1)';\n\n    // Exposed reference to the ripple that will be returned.\n    const rippleRef = new RippleRef(this, ripple, config);\n\n    rippleRef.state = RippleState.FADING_IN;\n\n    // Add the ripple reference to the list of all active ripples.\n    this._activeRipples.add(rippleRef);\n\n    if (!config.persistent) {\n      this._mostRecentTransientRipple = rippleRef;\n    }\n\n    // Wait for the ripple element to be completely faded in.\n    // Once it's faded in, the ripple can be hidden immediately if the mouse is released.\n    this.runTimeoutOutsideZone(() => {\n      const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;\n\n      rippleRef.state = RippleState.VISIBLE;\n\n      // When the timer runs out while the user has kept their pointer down, we want to\n      // keep only the persistent ripples and the latest transient ripple. We do this,\n      // because we don't want stacked transient ripples to appear after their enter\n      // animation has finished.\n      if (!config.persistent && (!isMostRecentTransientRipple || !this._isPointerDown)) {\n        rippleRef.fadeOut();\n      }\n    }, duration);\n\n    return rippleRef;\n  }\n\n  /** Fades out a ripple reference. */\n  fadeOutRipple(rippleRef: RippleRef) {\n    const wasActive = this._activeRipples.delete(rippleRef);\n\n    if (rippleRef === this._mostRecentTransientRipple) {\n      this._mostRecentTransientRipple = null;\n    }\n\n    // Clear out the cached bounding rect if we have no more ripples.\n    if (!this._activeRipples.size) {\n      this._containerRect = null;\n    }\n\n    // For ripples that are not active anymore, don't re-run the fade-out animation.\n    if (!wasActive) {\n      return;\n    }\n\n    const rippleEl = rippleRef.element;\n    const animationConfig = {...defaultRippleAnimationConfig, ...rippleRef.config.animation};\n\n    rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`;\n    rippleEl.style.opacity = '0';\n    rippleRef.state = RippleState.FADING_OUT;\n\n    // Once the ripple faded out, the ripple can be safely removed from the DOM.\n    this.runTimeoutOutsideZone(() => {\n      rippleRef.state = RippleState.HIDDEN;\n      rippleEl.parentNode!.removeChild(rippleEl);\n    }, animationConfig.exitDuration);\n  }\n\n  /** Fades out all currently active ripples. */\n  fadeOutAll() {\n    this._activeRipples.forEach(ripple => ripple.fadeOut());\n  }\n\n  /** Sets up the trigger event listeners */\n  setupTriggerEvents(element: HTMLElement) {\n    if (!element || element === this._triggerElement) {\n      return;\n    }\n\n    // Remove all previously registered event listeners from the trigger element.\n    this._removeTriggerEvents();\n\n    this._ngZone.runOutsideAngular(() => {\n      this._triggerEvents.forEach((fn, type) => {\n        element.addEventListener(type, fn, passiveEventOptions);\n      });\n    });\n\n    this._triggerElement = element;\n  }\n\n  /** Function being called whenever the trigger is being pressed using mouse. */\n  private onMousedown = (event: MouseEvent) => {\n    // Screen readers will fire fake mouse events for space/enter. Skip launching a\n    // ripple in this case for consistency with the non-screen-reader experience.\n    const isFakeMousedown = isFakeMousedownFromScreenReader(event);\n    const isSyntheticEvent = this._lastTouchStartEvent &&\n        Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;\n\n    if (!this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {\n      this._isPointerDown = true;\n      this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig);\n    }\n  }\n\n  /** Function being called whenever the trigger is being pressed using touch. */\n  private onTouchStart = (event: TouchEvent) => {\n    if (!this._target.rippleDisabled) {\n      // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse\n      // events will launch a second ripple if we don't ignore mouse events for a specific\n      // time after a touchstart event.\n      this._lastTouchStartEvent = Date.now();\n      this._isPointerDown = true;\n\n      // Use `changedTouches` so we skip any touches where the user put\n      // their finger down, but used another finger to tap the element again.\n      const touches = event.changedTouches;\n\n      for (let i = 0; i < touches.length; i++) {\n        this.fadeInRipple(touches[i].clientX, touches[i].clientY, this._target.rippleConfig);\n      }\n    }\n  }\n\n  /** Function being called whenever the trigger is being released. */\n  private onPointerUp = () => {\n    if (!this._isPointerDown) {\n      return;\n    }\n\n    this._isPointerDown = false;\n\n    // Fade-out all ripples that are visible and not persistent.\n    this._activeRipples.forEach(ripple => {\n      // By default, only ripples that are completely visible will fade out on pointer release.\n      // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.\n      const isVisible = ripple.state === RippleState.VISIBLE ||\n        ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN;\n\n      if (!ripple.config.persistent && isVisible) {\n        ripple.fadeOut();\n      }\n    });\n  }\n\n  /** Runs a timeout outside of the Angular zone to avoid triggering the change detection. */\n  private runTimeoutOutsideZone(fn: Function, delay = 0) {\n    this._ngZone.runOutsideAngular(() => setTimeout(fn, delay));\n  }\n\n  /** Removes previously registered event listeners from the trigger element. */\n  _removeTriggerEvents() {\n    if (this._triggerElement) {\n      this._triggerEvents.forEach((fn, type) => {\n        this._triggerElement!.removeEventListener(type, fn, passiveEventOptions);\n      });\n    }\n  }\n}\n\n/** Enforces a style recalculation of a DOM element by computing its styles. */\nfunction enforceStyleRecalculation(element: HTMLElement) {\n  // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.\n  // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.\n  // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n  window.getComputedStyle(element).getPropertyValue('opacity');\n}\n\n/**\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\n */\nfunction distanceToFurthestCorner(x: number, y: number, rect: ClientRect) {\n  const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n  const distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n  return Math.sqrt(distX * distX + distY * distY);\n}\n"]}