{"version":3,"file":"tab-group.js","sourceRoot":"","sources":["../../../../src/lib/tabs/tab-group.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty, coerceNumberProperty} from '@angular/cdk/coercion';\nimport {\n  AfterContentChecked,\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n  InjectionToken,\n  Inject,\n  Optional,\n} from '@angular/core';\nimport {\n  CanColor,\n  CanColorCtor,\n  CanDisableRipple,\n  CanDisableRippleCtor,\n  mixinColor,\n  mixinDisableRipple,\n  ThemePalette,\n} from '@angular/material/core';\nimport {merge, Subscription} from 'rxjs';\nimport {MatTab} from './tab';\nimport {MatTabHeader} from './tab-header';\n\n\n/** Used to generate unique ID's for each tab component */\nlet nextId = 0;\n\n/** A simple change event emitted on focus or selection changes. */\nexport class MatTabChangeEvent {\n  /** Index of the currently-selected tab. */\n  index: number;\n  /** Reference to the currently-selected tab. */\n  tab: MatTab;\n}\n\n/** Possible positions for the tab header. */\nexport type MatTabHeaderPosition = 'above' | 'below';\n\n/** Object that can be used to configure the default options for the tabs module. */\nexport interface MatTabsConfig {\n  /** Duration for the tab animation. Must be a valid CSS value (e.g. 600ms). */\n  animationDuration?: string;\n}\n\n/** Injection token that can be used to provide the default options the tabs module. */\nexport const MAT_TABS_CONFIG = new InjectionToken('MAT_TABS_CONFIG');\n\n// Boilerplate for applying mixins to MatTabGroup.\n/** @docs-private */\nexport class MatTabGroupBase {\n  constructor(public _elementRef: ElementRef) {}\n}\nexport const _MatTabGroupMixinBase: CanColorCtor & CanDisableRippleCtor & typeof MatTabGroupBase =\n    mixinColor(mixinDisableRipple(MatTabGroupBase), 'primary');\n\n/**\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://material.io/design/components/tabs.html\n */\n@Component({\n  moduleId: module.id,\n  selector: 'mat-tab-group',\n  exportAs: 'matTabGroup',\n  templateUrl: 'tab-group.html',\n  styleUrls: ['tab-group.css'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  inputs: ['color', 'disableRipple'],\n  host: {\n    'class': 'mat-tab-group',\n    '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',\n    '[class.mat-tab-group-inverted-header]': 'headerPosition === \"below\"',\n  },\n})\nexport class MatTabGroup extends _MatTabGroupMixinBase implements AfterContentInit,\n    AfterContentChecked, OnDestroy, CanColor, CanDisableRipple {\n\n  @ContentChildren(MatTab) _tabs: QueryList<MatTab>;\n\n  @ViewChild('tabBodyWrapper') _tabBodyWrapper: ElementRef;\n\n  @ViewChild('tabHeader') _tabHeader: MatTabHeader;\n\n  /** The tab index that should be selected after the content has been checked. */\n  private _indexToSelect: number | null = 0;\n\n  /** Snapshot of the height of the tab body wrapper before another tab is activated. */\n  private _tabBodyWrapperHeight: number = 0;\n\n  /** Subscription to tabs being added/removed. */\n  private _tabsSubscription = Subscription.EMPTY;\n\n  /** Subscription to changes in the tab labels. */\n  private _tabLabelSubscription = Subscription.EMPTY;\n\n  /** Whether the tab group should grow to the size of the active tab. */\n  @Input()\n  get dynamicHeight(): boolean { return this._dynamicHeight; }\n  set dynamicHeight(value: boolean) { this._dynamicHeight = coerceBooleanProperty(value); }\n  private _dynamicHeight: boolean = false;\n\n  /** The index of the active tab. */\n  @Input()\n  get selectedIndex(): number | null { return this._selectedIndex; }\n  set selectedIndex(value: number | null) {\n    this._indexToSelect = coerceNumberProperty(value, null);\n  }\n  private _selectedIndex: number | null = null;\n\n  /** Position of the tab header. */\n  @Input() headerPosition: MatTabHeaderPosition = 'above';\n\n  /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n  @Input()\n  get animationDuration(): string { return this._animationDuration; }\n  set animationDuration(value: string) {\n    this._animationDuration = /^\\d+$/.test(value) ? value + 'ms' : value;\n  }\n  private _animationDuration: string;\n\n  /** Background color of the tab group. */\n  @Input()\n  get backgroundColor(): ThemePalette { return this._backgroundColor; }\n  set backgroundColor(value: ThemePalette) {\n    const nativeElement: HTMLElement = this._elementRef.nativeElement;\n\n    nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n\n    if (value) {\n      nativeElement.classList.add(`mat-background-${value}`);\n    }\n\n    this._backgroundColor = value;\n  }\n  private _backgroundColor: ThemePalette;\n\n  /** Output to enable support for two-way binding on `[(selectedIndex)]` */\n  @Output() readonly selectedIndexChange: EventEmitter<number> = new EventEmitter<number>();\n\n  /** Event emitted when focus has changed within a tab group. */\n  @Output() readonly focusChange: EventEmitter<MatTabChangeEvent> =\n      new EventEmitter<MatTabChangeEvent>();\n\n  /** Event emitted when the body animation has completed */\n  @Output() readonly animationDone: EventEmitter<void> = new EventEmitter<void>();\n\n  /** Event emitted when the tab selection has changed. */\n  @Output() readonly selectedTabChange: EventEmitter<MatTabChangeEvent> =\n      new EventEmitter<MatTabChangeEvent>(true);\n\n  private _groupId: number;\n\n  constructor(elementRef: ElementRef,\n              private _changeDetectorRef: ChangeDetectorRef,\n              @Inject(MAT_TABS_CONFIG) @Optional() defaultConfig?: MatTabsConfig) {\n    super(elementRef);\n    this._groupId = nextId++;\n    this.animationDuration = defaultConfig && defaultConfig.animationDuration ?\n        defaultConfig.animationDuration : '500ms';\n  }\n\n  /**\n   * After the content is checked, this component knows what tabs have been defined\n   * and what the selected index should be. This is where we can know exactly what position\n   * each tab should be in according to the new selected index, and additionally we know how\n   * a new selected tab should transition in (from the left or right).\n   */\n  ngAfterContentChecked() {\n    // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n    // the amount of tabs changes before the actual change detection runs.\n    const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n\n    // If there is a change in selected index, emit a change event. Should not trigger if\n    // the selected index has not yet been initialized.\n    if (this._selectedIndex != indexToSelect) {\n      const isFirstRun = this._selectedIndex == null;\n\n      if (!isFirstRun) {\n        this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n      }\n\n      // Changing these values after change detection has run\n      // since the checked content may contain references to them.\n      Promise.resolve().then(() => {\n        this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);\n\n        if (!isFirstRun) {\n          this.selectedIndexChange.emit(indexToSelect);\n        }\n      });\n    }\n\n    // Setup the position for each tab and optionally setup an origin on the next selected tab.\n    this._tabs.forEach((tab: MatTab, index: number) => {\n      tab.position = index - indexToSelect;\n\n      // If there is already a selected tab, then set up an origin for the next selected tab\n      // if it doesn't have one already.\n      if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n        tab.origin = indexToSelect - this._selectedIndex;\n      }\n    });\n\n    if (this._selectedIndex !== indexToSelect) {\n      this._selectedIndex = indexToSelect;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  ngAfterContentInit() {\n    this._subscribeToTabLabels();\n\n    // Subscribe to changes in the amount of tabs, in order to be\n    // able to re-render the content as new tabs are added or removed.\n    this._tabsSubscription = this._tabs.changes.subscribe(() => {\n      const indexToSelect = this._clampTabIndex(this._indexToSelect);\n\n      // Maintain the previously-selected tab if a new tab is added or removed and there is no\n      // explicit change that selects a different tab.\n      if (indexToSelect === this._selectedIndex) {\n        const tabs = this._tabs.toArray();\n\n        for (let i = 0; i < tabs.length; i++) {\n          if (tabs[i].isActive) {\n            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n            // adding a tab within the `selectedIndexChange` event.\n            this._indexToSelect = this._selectedIndex = i;\n            break;\n          }\n        }\n      }\n\n      this._subscribeToTabLabels();\n      this._changeDetectorRef.markForCheck();\n    });\n  }\n\n  ngOnDestroy() {\n    this._tabsSubscription.unsubscribe();\n    this._tabLabelSubscription.unsubscribe();\n  }\n\n  /** Re-aligns the ink bar to the selected tab element. */\n  realignInkBar() {\n    if (this._tabHeader) {\n      this._tabHeader._alignInkBarToSelectedTab();\n    }\n  }\n\n  _focusChanged(index: number) {\n    this.focusChange.emit(this._createChangeEvent(index));\n  }\n\n  private _createChangeEvent(index: number): MatTabChangeEvent {\n    const event = new MatTabChangeEvent;\n    event.index = index;\n    if (this._tabs && this._tabs.length) {\n      event.tab = this._tabs.toArray()[index];\n    }\n    return event;\n  }\n\n  /**\n   * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n   * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n   * binding to be updated, we need to subscribe to changes in it and trigger change detection\n   * manually.\n   */\n  private _subscribeToTabLabels() {\n    if (this._tabLabelSubscription) {\n      this._tabLabelSubscription.unsubscribe();\n    }\n\n    this._tabLabelSubscription = merge(...this._tabs.map(tab => tab._stateChanges))\n      .subscribe(() => this._changeDetectorRef.markForCheck());\n  }\n\n  /** Clamps the given index to the bounds of 0 and the tabs length. */\n  private _clampTabIndex(index: number | null): number {\n    // Note the `|| 0`, which ensures that values like NaN can't get through\n    // and which would otherwise throw the component into an infinite loop\n    // (since Math.max(NaN, 0) === NaN).\n    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n  }\n\n  /** Returns a unique id for each tab label element */\n  _getTabLabelId(i: number): string {\n    return `mat-tab-label-${this._groupId}-${i}`;\n  }\n\n  /** Returns a unique id for each tab content element */\n  _getTabContentId(i: number): string {\n    return `mat-tab-content-${this._groupId}-${i}`;\n  }\n\n  /**\n   * Sets the height of the body wrapper to the height of the activating tab if dynamic\n   * height property is true.\n   */\n  _setTabBodyWrapperHeight(tabHeight: number): void {\n    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) { return; }\n\n    const wrapper: HTMLElement = this._tabBodyWrapper.nativeElement;\n\n    wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n\n    // This conditional forces the browser to paint the height so that\n    // the animation to the new height can have an origin.\n    if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n      wrapper.style.height = tabHeight + 'px';\n    }\n  }\n\n  /** Removes the height of the tab body wrapper. */\n  _removeTabBodyWrapperHeight(): void {\n    const wrapper = this._tabBodyWrapper.nativeElement;\n    this._tabBodyWrapperHeight = wrapper.clientHeight;\n    wrapper.style.height = '';\n    this.animationDone.emit();\n  }\n\n  /** Handle click events, setting new selected index if appropriate. */\n  _handleClick(tab: MatTab, tabHeader: MatTabHeader, index: number) {\n    if (!tab.disabled) {\n      this.selectedIndex = tabHeader.focusIndex = index;\n    }\n  }\n\n  /** Retrieves the tabindex for the tab. */\n  _getTabIndex(tab: MatTab, idx: number): number | null {\n    if (tab.disabled) {\n      return null;\n    }\n    return this.selectedIndex === idx ? 0 : -1;\n  }\n}\n"]}