{"version":3,"file":"tab-header.js","sourceRoot":"","sources":["../../../../../src/lib/tabs/tab-header.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Direction, Directionality} from '@angular/cdk/bidi';\nimport {coerceNumberProperty} from '@angular/cdk/coercion';\nimport {END, ENTER, HOME, SPACE, hasModifierKey} from '@angular/cdk/keycodes';\nimport {ViewportRuler} from '@angular/cdk/scrolling';\nimport {\n  AfterContentChecked,\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  ElementRef,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  QueryList,\n  ViewChild,\n  ViewEncapsulation,\n  AfterViewInit,\n} from '@angular/core';\nimport {CanDisableRipple, CanDisableRippleCtor, mixinDisableRipple} from '@angular/material/core';\nimport {merge, of as observableOf, Subject, timer, fromEvent} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {MatInkBar} from './ink-bar';\nimport {MatTabLabelWrapper} from './tab-label-wrapper';\nimport {FocusKeyManager} from '@angular/cdk/a11y';\nimport {Platform, normalizePassiveListenerOptions} from '@angular/cdk/platform';\n\n\n/** Config used to bind passive event listeners */\nconst passiveEventListenerOptions =\n    normalizePassiveListenerOptions({passive: true}) as EventListenerOptions;\n\n/**\n * The directions that scrolling can go in when the header's tabs exceed the header width. 'After'\n * will scroll the header towards the end of the tabs list and 'before' will scroll towards the\n * beginning of the list.\n */\nexport type ScrollDirection = 'after' | 'before';\n\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n * Set a little conservatively in order to handle fake events dispatched on touch devices.\n */\nconst HEADER_SCROLL_DELAY = 650;\n\n/**\n * Interval in milliseconds at which to scroll the header\n * while the user is holding their pointer.\n */\nconst HEADER_SCROLL_INTERVAL = 100;\n\n// Boilerplate for applying mixins to MatTabHeader.\n/** @docs-private */\nexport class MatTabHeaderBase {}\nexport const _MatTabHeaderMixinBase: CanDisableRippleCtor & typeof MatTabHeaderBase =\n    mixinDisableRipple(MatTabHeaderBase);\n\n/**\n * The header of the tab group which displays a list of all the tabs in the tab group. Includes\n * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the\n * width of the header container, then arrows will be displayed to allow the user to scroll\n * left and right across the header.\n * @docs-private\n */\n@Component({\n  moduleId: module.id,\n  selector: 'mat-tab-header',\n  templateUrl: 'tab-header.html',\n  styleUrls: ['tab-header.css'],\n  inputs: ['disableRipple'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    'class': 'mat-tab-header',\n    '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',\n    '[class.mat-tab-header-rtl]': \"_getLayoutDirection() == 'rtl'\",\n  },\n})\nexport class MatTabHeader extends _MatTabHeaderMixinBase\n    implements AfterContentChecked, AfterContentInit, AfterViewInit, OnDestroy, CanDisableRipple {\n\n  @ContentChildren(MatTabLabelWrapper) _labelWrappers: QueryList<MatTabLabelWrapper>;\n  @ViewChild(MatInkBar) _inkBar: MatInkBar;\n  @ViewChild('tabListContainer') _tabListContainer: ElementRef;\n  @ViewChild('tabList') _tabList: ElementRef;\n  @ViewChild('nextPaginator') _nextPaginator: ElementRef<HTMLElement>;\n  @ViewChild('previousPaginator') _previousPaginator: ElementRef<HTMLElement>;\n\n  /** The distance in pixels that the tab labels should be translated to the left. */\n  private _scrollDistance = 0;\n\n  /** Whether the header should scroll to the selected index after the view has been checked. */\n  private _selectedIndexChanged = false;\n\n  /** Emits when the component is destroyed. */\n  private readonly _destroyed = new Subject<void>();\n\n  /** Whether the controls for pagination should be displayed */\n  _showPaginationControls = false;\n\n  /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n  _disableScrollAfter = true;\n\n  /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n  _disableScrollBefore = true;\n\n  /**\n   * The number of tab labels that are displayed on the header. When this changes, the header\n   * should re-evaluate the scroll position.\n   */\n  private _tabLabelCount: number;\n\n  /** Whether the scroll distance has changed and should be applied after the view is checked. */\n  private _scrollDistanceChanged: boolean;\n\n  /** Used to manage focus between the tabs. */\n  private _keyManager: FocusKeyManager<MatTabLabelWrapper>;\n\n  /** Cached text content of the header. */\n  private _currentTextContent: string;\n\n  /** Stream that will stop the automated scrolling. */\n  private _stopScrolling = new Subject<void>();\n\n  /** The index of the active tab. */\n  @Input()\n  get selectedIndex(): number { return this._selectedIndex; }\n  set selectedIndex(value: number) {\n    value = coerceNumberProperty(value);\n    this._selectedIndexChanged = this._selectedIndex != value;\n    this._selectedIndex = value;\n\n    if (this._keyManager) {\n      this._keyManager.updateActiveItemIndex(value);\n    }\n  }\n  private _selectedIndex: number = 0;\n\n  /** Event emitted when the option is selected. */\n  @Output() readonly selectFocusedIndex: EventEmitter<number> = new EventEmitter<number>();\n\n  /** Event emitted when a label is focused. */\n  @Output() readonly indexFocused: EventEmitter<number> = new EventEmitter<number>();\n\n  constructor(private _elementRef: ElementRef,\n              private _changeDetectorRef: ChangeDetectorRef,\n              private _viewportRuler: ViewportRuler,\n              @Optional() private _dir: Directionality,\n              // @breaking-change 8.0.0 `_ngZone` and `_platforms` parameters to be made required.\n              private _ngZone?: NgZone,\n              private _platform?: Platform) {\n    super();\n\n    const element = _elementRef.nativeElement;\n    const bindEvent = () => {\n      fromEvent(element, 'mouseleave')\n        .pipe(takeUntil(this._destroyed))\n        .subscribe(() => {\n          this._stopInterval();\n        });\n    };\n\n    // @breaking-change 8.0.0 remove null check once _ngZone is made into a required parameter.\n    if (_ngZone) {\n      // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n      _ngZone.runOutsideAngular(bindEvent);\n    } else {\n      bindEvent();\n    }\n  }\n\n  ngAfterContentChecked(): void {\n    // If the number of tab labels have changed, check if scrolling should be enabled\n    if (this._tabLabelCount != this._labelWrappers.length) {\n      this.updatePagination();\n      this._tabLabelCount = this._labelWrappers.length;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the selected index has changed, scroll to the label and check if the scrolling controls\n    // should be disabled.\n    if (this._selectedIndexChanged) {\n      this._scrollToLabel(this._selectedIndex);\n      this._checkScrollingControls();\n      this._alignInkBarToSelectedTab();\n      this._selectedIndexChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n\n    // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n    // then translate the header to reflect this.\n    if (this._scrollDistanceChanged) {\n      this._updateTabScrollPosition();\n      this._scrollDistanceChanged = false;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n\n  /** Handles keyboard events on the header. */\n  _handleKeydown(event: KeyboardEvent) {\n    // We don't handle any key bindings with a modifier key.\n    if (hasModifierKey(event)) {\n      return;\n    }\n\n    switch (event.keyCode) {\n      case HOME:\n        this._keyManager.setFirstItemActive();\n        event.preventDefault();\n        break;\n      case END:\n        this._keyManager.setLastItemActive();\n        event.preventDefault();\n        break;\n      case ENTER:\n      case SPACE:\n        this.selectFocusedIndex.emit(this.focusIndex);\n        event.preventDefault();\n        break;\n      default:\n        this._keyManager.onKeydown(event);\n    }\n  }\n\n  /**\n   * Aligns the ink bar to the selected tab on load.\n   */\n  ngAfterContentInit() {\n    const dirChange = this._dir ? this._dir.change : observableOf(null);\n    const resize = this._viewportRuler.change(150);\n    const realign = () => {\n      this.updatePagination();\n      this._alignInkBarToSelectedTab();\n    };\n\n    this._keyManager = new FocusKeyManager(this._labelWrappers)\n      .withHorizontalOrientation(this._getLayoutDirection())\n      .withWrap();\n\n    this._keyManager.updateActiveItem(0);\n\n    // Defer the first call in order to allow for slower browsers to lay out the elements.\n    // This helps in cases where the user lands directly on a page with paginated tabs.\n    typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n\n    // On dir change or window resize, realign the ink bar and update the orientation of\n    // the key manager if the direction has changed.\n    merge(dirChange, resize).pipe(takeUntil(this._destroyed)).subscribe(() => {\n      realign();\n      this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n    });\n\n    // If there is a change in the focus key manager we need to emit the `indexFocused`\n    // event in order to provide a public event that notifies about focus changes. Also we realign\n    // the tabs container by scrolling the new focused tab into the visible section.\n    this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(newFocusIndex => {\n      this.indexFocused.emit(newFocusIndex);\n      this._setTabFocus(newFocusIndex);\n    });\n  }\n\n  ngAfterViewInit() {\n    // We need to handle these events manually, because we want to bind passive event listeners.\n    fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => {\n        this._handlePaginatorPress('before');\n      });\n\n    fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n      .pipe(takeUntil(this._destroyed))\n      .subscribe(() => {\n        this._handlePaginatorPress('after');\n      });\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n    this._stopScrolling.complete();\n  }\n\n  /**\n   * Callback for when the MutationObserver detects that the content has changed.\n   */\n  _onContentChanges() {\n    const textContent = this._elementRef.nativeElement.textContent;\n\n    // We need to diff the text content of the header, because the MutationObserver callback\n    // will fire even if the text content didn't change which is inefficient and is prone\n    // to infinite loops if a poorly constructed expression is passed in (see #14249).\n    if (textContent !== this._currentTextContent) {\n      this._currentTextContent = textContent;\n\n      const zoneCallback = () => {\n        this.updatePagination();\n        this._alignInkBarToSelectedTab();\n        this._changeDetectorRef.markForCheck();\n      };\n\n      // The content observer runs outside the `NgZone` by default, which\n      // means that we need to bring the callback back in ourselves.\n      // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.\n      this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();\n    }\n  }\n\n  /**\n   * Updates the view whether pagination should be enabled or not.\n   *\n   * WARNING: Calling this method can be very costly in terms of performance.  It should be called\n   * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n   * page.\n   */\n  updatePagination() {\n    this._checkPaginationEnabled();\n    this._checkScrollingControls();\n    this._updateTabScrollPosition();\n  }\n\n  /** Tracks which element has focus; used for keyboard navigation */\n  get focusIndex(): number {\n    return this._keyManager ? this._keyManager.activeItemIndex! : 0;\n  }\n\n  /** When the focus index is set, we must manually send focus to the correct label */\n  set focusIndex(value: number) {\n    if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n      return;\n    }\n\n    this._keyManager.setActiveItem(value);\n  }\n\n  /**\n   * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n   * providing a valid index and return true.\n   */\n  _isValidIndex(index: number): boolean {\n    if (!this._labelWrappers) { return true; }\n\n    const tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;\n    return !!tab && !tab.disabled;\n  }\n\n  /**\n   * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n   * scrolling is enabled.\n   */\n  _setTabFocus(tabIndex: number) {\n    if (this._showPaginationControls) {\n      this._scrollToLabel(tabIndex);\n    }\n\n    if (this._labelWrappers && this._labelWrappers.length) {\n      this._labelWrappers.toArray()[tabIndex].focus();\n\n      // Do not let the browser manage scrolling to focus the element, this will be handled\n      // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n      // should be the full width minus the offset width.\n      const containerEl = this._tabListContainer.nativeElement;\n      const dir = this._getLayoutDirection();\n\n      if (dir == 'ltr') {\n        containerEl.scrollLeft = 0;\n      } else {\n        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n      }\n    }\n  }\n\n  /** The layout direction of the containing app. */\n  _getLayoutDirection(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n  _updateTabScrollPosition() {\n    const scrollDistance = this.scrollDistance;\n    const platform = this._platform;\n    const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n\n    // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n    // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n    // and ripples will exceed the boundaries of the visible tab bar.\n    // See: https://github.com/angular/material2/issues/10276\n    // We round the `transform` here, because transforms with sub-pixel precision cause some\n    // browsers to blur the content of the element.\n    this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;\n\n    // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n    // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n    // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n    // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n    // @breaking-change 8.0.0 Remove null check for `platform`.\n    if (platform && (platform.TRIDENT || platform.EDGE)) {\n      this._tabListContainer.nativeElement.scrollLeft = 0;\n    }\n  }\n\n  /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n  get scrollDistance(): number { return this._scrollDistance; }\n  set scrollDistance(value: number) {\n    this._scrollTo(value);\n  }\n\n  /**\n   * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n   * the end of the list, respectively). The distance to scroll is computed to be a third of the\n   * length of the tab list view window.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollHeader(direction: ScrollDirection) {\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    // Move the scroll distance one-third the length of the tab list's viewport.\n    const scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n\n    return this._scrollTo(this._scrollDistance + scrollAmount);\n  }\n\n  /** Handles click events on the pagination arrows. */\n  _handlePaginatorClick(direction: ScrollDirection) {\n    this._stopInterval();\n    this._scrollHeader(direction);\n  }\n\n  /**\n   * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _scrollToLabel(labelIndex: number) {\n    const selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;\n\n    if (!selectedLabel) { return; }\n\n    // The view length is the visible width of the tab labels.\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n\n    let labelBeforePos: number, labelAfterPos: number;\n    if (this._getLayoutDirection() == 'ltr') {\n      labelBeforePos = selectedLabel.getOffsetLeft();\n      labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();\n    } else {\n      labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();\n      labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();\n    }\n\n    const beforeVisiblePos = this.scrollDistance;\n    const afterVisiblePos = this.scrollDistance + viewLength;\n\n    if (labelBeforePos < beforeVisiblePos) {\n      // Scroll header to move label to the before direction\n      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n    } else if (labelAfterPos > afterVisiblePos) {\n      // Scroll header to move label to the after direction\n      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n    }\n  }\n\n  /**\n   * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n   * tab list is wider than the size of the header container, then the pagination controls should\n   * be shown.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkPaginationEnabled() {\n    const isEnabled =\n        this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n\n    if (!isEnabled) {\n      this.scrollDistance = 0;\n    }\n\n    if (isEnabled !== this._showPaginationControls) {\n      this._changeDetectorRef.markForCheck();\n    }\n\n    this._showPaginationControls = isEnabled;\n  }\n\n  /**\n   * Evaluate whether the before and after controls should be enabled or disabled.\n   * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n   * before button. If the header is at the end of the list (scroll distance is equal to the\n   * maximum distance we can scroll), then disable the after button.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _checkScrollingControls() {\n    // Check if the pagination arrows should be activated.\n    this._disableScrollBefore = this.scrollDistance == 0;\n    this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /**\n   * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n   * is equal to the difference in width between the tab list container and tab header container.\n   *\n   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n   * should be called sparingly.\n   */\n  _getMaxScrollDistance(): number {\n    const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n    const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n    return (lengthOfTabList - viewLength) || 0;\n  }\n\n  /** Tells the ink-bar to align itself to the current label wrapper */\n  _alignInkBarToSelectedTab(): void {\n    const selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ?\n        this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement :\n        null;\n\n    this._inkBar.alignToElement(selectedLabelWrapper!);\n  }\n\n  /** Stops the currently-running paginator interval.  */\n  _stopInterval() {\n    this._stopScrolling.next();\n  }\n\n  /**\n   * Handles the user pressing down on one of the paginators.\n   * Starts scrolling the header after a certain amount of time.\n   * @param direction In which direction the paginator should be scrolled.\n   */\n  _handlePaginatorPress(direction: ScrollDirection) {\n    // Avoid overlapping timers.\n    this._stopInterval();\n\n    // Start a timer after the delay and keep firing based on the interval.\n    timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n      // Keep the timer going until something tells it to stop or the component is destroyed.\n      .pipe(takeUntil(merge(this._stopScrolling, this._destroyed)))\n      .subscribe(() => {\n        const {maxScrollDistance, distance} = this._scrollHeader(direction);\n\n        // Stop the timer if we've reached the start or the end.\n        if (distance === 0 || distance >= maxScrollDistance) {\n          this._stopInterval();\n        }\n      });\n  }\n\n  /**\n   * Scrolls the header to a given position.\n   * @param position Position to which to scroll.\n   * @returns Information on the current scroll distance and the maximum.\n   */\n  private _scrollTo(position: number) {\n    const maxScrollDistance = this._getMaxScrollDistance();\n    this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n\n    // Mark that the scroll distance has changed so that after the view is checked, the CSS\n    // transformation can move the header.\n    this._scrollDistanceChanged = true;\n    this._checkScrollingControls();\n\n    return {maxScrollDistance, distance: this._scrollDistance};\n  }\n}\n"]}