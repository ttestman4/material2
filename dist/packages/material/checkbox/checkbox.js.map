{"version":3,"file":"checkbox.js","sourceRoot":"","sources":["../../../../src/lib/checkbox/checkbox.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor} from '@angular/cdk/a11y';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {\n  Attribute,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  Inject,\n  Input,\n  NgZone,\n  OnDestroy,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation,\n  AfterViewChecked,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR} from '@angular/forms';\nimport {\n  CanColor,\n  CanColorCtor,\n  CanDisable,\n  CanDisableCtor,\n  CanDisableRipple,\n  CanDisableRippleCtor,\n  HasTabIndex,\n  HasTabIndexCtor,\n  MatRipple,\n  mixinColor,\n  mixinDisabled,\n  mixinDisableRipple,\n  mixinTabIndex,\n} from '@angular/material/core';\nimport {ANIMATION_MODULE_TYPE} from '@angular/platform-browser/animations';\nimport {MAT_CHECKBOX_CLICK_ACTION, MatCheckboxClickAction} from './checkbox-config';\n\n\n// Increasing integer for generating unique ids for checkbox components.\nlet nextUniqueId = 0;\n\n// TODO(josephperrott): Revert to constants for ripple radius once 2018 Checkbox updates have\n// landed.\n// The radius for the checkbox's ripple, in pixels.\nlet calculatedRippleRadius = 0;\n\n/**\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nexport const MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MatCheckbox),\n  multi: true\n};\n\n/**\n * Represents the different states that require custom transitions between them.\n * @docs-private\n */\nexport enum TransitionCheckState {\n  /** The initial state of the component before any user interaction. */\n  Init,\n  /** The state representing the component when it's becoming checked. */\n  Checked,\n  /** The state representing the component when it's becoming unchecked. */\n  Unchecked,\n  /** The state representing the component when it's becoming indeterminate. */\n  Indeterminate\n}\n\n/** Change event object emitted by MatCheckbox. */\nexport class MatCheckboxChange {\n  /** The source MatCheckbox of the event. */\n  source: MatCheckbox;\n  /** The new `checked` value of the checkbox. */\n  checked: boolean;\n}\n\n// Boilerplate for applying mixins to MatCheckbox.\n/** @docs-private */\nexport class MatCheckboxBase {\n  constructor(public _elementRef: ElementRef) {}\n}\nexport const _MatCheckboxMixinBase:\n    HasTabIndexCtor &\n    CanColorCtor &\n    CanDisableRippleCtor &\n    CanDisableCtor &\n    typeof MatCheckboxBase =\n        mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatCheckboxBase)), 'accent'));\n\n\n/**\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\n * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\n * so there is no need to provide them yourself. However, if you want to omit a label and still\n * have the checkbox be accessible, you may supply an [aria-label] input.\n * See: https://material.io/design/components/selection-controls.html\n */\n@Component({\n  moduleId: module.id,\n  selector: 'mat-checkbox',\n  templateUrl: 'checkbox.html',\n  styleUrls: ['checkbox.css'],\n  exportAs: 'matCheckbox',\n  host: {\n    'class': 'mat-checkbox',\n    '[id]': 'id',\n    '[attr.tabindex]': 'null',\n    '[class.mat-checkbox-indeterminate]': 'indeterminate',\n    '[class.mat-checkbox-checked]': 'checked',\n    '[class.mat-checkbox-disabled]': 'disabled',\n    '[class.mat-checkbox-label-before]': 'labelPosition == \"before\"',\n    '[class._mat-animation-noopable]': `_animationMode === 'NoopAnimations'`,\n  },\n  providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR],\n  inputs: ['disableRipple', 'color', 'tabIndex'],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class MatCheckbox extends _MatCheckboxMixinBase implements ControlValueAccessor,\n    AfterViewChecked, OnDestroy, CanColor, CanDisable, HasTabIndex, CanDisableRipple {\n\n  /**\n   * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will\n   * take precedence so this may be omitted.\n   */\n  @Input('aria-label') ariaLabel: string = '';\n\n  /**\n   * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n   */\n  @Input('aria-labelledby') ariaLabelledby: string | null = null;\n\n  private _uniqueId: string = `mat-checkbox-${++nextUniqueId}`;\n\n  /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\n  @Input() id: string = this._uniqueId;\n\n  /** Returns the unique id for the visual hidden input. */\n  get inputId(): string { return `${this.id || this._uniqueId}-input`; }\n\n  /** Whether the checkbox is required. */\n  @Input()\n  get required(): boolean { return this._required; }\n  set required(value: boolean) { this._required = coerceBooleanProperty(value); }\n  private _required: boolean;\n\n  /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\n  @Input() labelPosition: 'before' | 'after' = 'after';\n\n  /** Name value will be applied to the input element if present */\n  @Input() name: string | null = null;\n\n  /** Event emitted when the checkbox's `checked` value changes. */\n  @Output() readonly change: EventEmitter<MatCheckboxChange> =\n      new EventEmitter<MatCheckboxChange>();\n\n  /** Event emitted when the checkbox's `indeterminate` value changes. */\n  @Output() readonly indeterminateChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n  /** The value attribute of the native input element */\n  @Input() value: string;\n\n  /** The native `<input type=\"checkbox\">` element */\n  @ViewChild('input') _inputElement: ElementRef<HTMLInputElement>;\n\n  /** Reference to the ripple instance of the checkbox. */\n  @ViewChild(MatRipple) ripple: MatRipple;\n\n  /**\n   * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n   * @docs-private\n   */\n  _onTouched: () => any = () => {};\n\n  private _currentAnimationClass: string = '';\n\n  private _currentCheckState: TransitionCheckState = TransitionCheckState.Init;\n\n  private _controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n  constructor(elementRef: ElementRef<HTMLElement>,\n              private _changeDetectorRef: ChangeDetectorRef,\n              private _focusMonitor: FocusMonitor,\n              private _ngZone: NgZone,\n              @Attribute('tabindex') tabIndex: string,\n              @Optional() @Inject(MAT_CHECKBOX_CLICK_ACTION)\n                  private _clickAction: MatCheckboxClickAction,\n              @Optional() @Inject(ANIMATION_MODULE_TYPE) public _animationMode?: string) {\n    super(elementRef);\n\n    this.tabIndex = parseInt(tabIndex) || 0;\n\n    this._focusMonitor.monitor(elementRef, true).subscribe(focusOrigin => {\n      if (!focusOrigin) {\n        // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n        // Angular does not expect events to be raised during change detection, so any state change\n        // (such as a form control's 'ng-touched') will cause a changed-after-checked error.\n        // See https://github.com/angular/angular/issues/17793. To work around this, we defer\n        // telling the form control it has been touched until the next tick.\n        Promise.resolve().then(() => {\n          this._onTouched();\n          _changeDetectorRef.markForCheck();\n        });\n      }\n    });\n  }\n\n  ngAfterViewChecked() {\n    this._calculateRippleRadius();\n  }\n\n  ngOnDestroy() {\n    this._focusMonitor.stopMonitoring(this._elementRef);\n  }\n\n  /**\n   * Whether the checkbox is checked.\n   */\n  @Input()\n  get checked(): boolean { return this._checked; }\n  set checked(value: boolean) {\n    if (value != this.checked) {\n      this._checked = value;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _checked: boolean = false;\n\n  /**\n   * Whether the checkbox is disabled. This fully overrides the implementation provided by\n   * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.\n   */\n  @Input()\n  get disabled() { return this._disabled; }\n  set disabled(value: any) {\n    const newValue = coerceBooleanProperty(value);\n\n    if (newValue !== this.disabled) {\n      this._disabled = newValue;\n      this._changeDetectorRef.markForCheck();\n    }\n  }\n  private _disabled: boolean = false;\n\n  /**\n   * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n   * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n   * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n   * set to false.\n   */\n  @Input()\n  get indeterminate(): boolean { return this._indeterminate; }\n  set indeterminate(value: boolean) {\n    const changed = value != this._indeterminate;\n    this._indeterminate = value;\n\n    if (changed) {\n      if (this._indeterminate) {\n        this._transitionCheckState(TransitionCheckState.Indeterminate);\n      } else {\n        this._transitionCheckState(\n          this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\n      }\n      this.indeterminateChange.emit(this._indeterminate);\n    }\n  }\n  private _indeterminate: boolean = false;\n\n  _isRippleDisabled() {\n    return this.disableRipple || this.disabled;\n  }\n\n  /** Method being called whenever the label text changes. */\n  _onLabelTextChange() {\n    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox\n    // component will be only marked for check, but no actual change detection runs automatically.\n    // Instead of going back into the zone in order to trigger a change detection which causes\n    // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger\n    // an explicit change detection for the checkbox view and it's children.\n    this._changeDetectorRef.detectChanges();\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  writeValue(value: any) {\n    this.checked = !!value;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnChange(fn: (value: any) => void) {\n    this._controlValueAccessorChangeFn = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  registerOnTouched(fn: any) {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor.\n  setDisabledState(isDisabled: boolean) {\n    this.disabled = isDisabled;\n  }\n\n  _getAriaChecked(): 'true' | 'false' | 'mixed' {\n    return this.checked ? 'true' : (this.indeterminate ? 'mixed' : 'false');\n  }\n\n  private _transitionCheckState(newState: TransitionCheckState) {\n    let oldState = this._currentCheckState;\n    let element: HTMLElement = this._elementRef.nativeElement;\n\n    if (oldState === newState) {\n      return;\n    }\n    if (this._currentAnimationClass.length > 0) {\n      element.classList.remove(this._currentAnimationClass);\n    }\n\n    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(\n        oldState, newState);\n    this._currentCheckState = newState;\n\n    if (this._currentAnimationClass.length > 0) {\n      element.classList.add(this._currentAnimationClass);\n\n      // Remove the animation class to avoid animation when the checkbox is moved between containers\n      const animationClass = this._currentAnimationClass;\n\n      this._ngZone.runOutsideAngular(() => {\n        setTimeout(() => {\n          element.classList.remove(animationClass);\n        }, 1000);\n      });\n    }\n  }\n\n  private _emitChangeEvent() {\n    const event = new MatCheckboxChange();\n    event.source = this;\n    event.checked = this.checked;\n\n    this._controlValueAccessorChangeFn(this.checked);\n    this.change.emit(event);\n  }\n\n  /** Toggles the `checked` state of the checkbox. */\n  toggle(): void {\n    this.checked = !this.checked;\n  }\n\n  /**\n   * Event handler for checkbox input element.\n   * Toggles checked state if element is not disabled.\n   * Do not toggle on (change) event since IE doesn't fire change event when\n   *   indeterminate checkbox is clicked.\n   * @param event\n   */\n  _onInputClick(event: Event) {\n    // We have to stop propagation for click events on the visual hidden input element.\n    // By default, when a user clicks on a label element, a generated click event will be\n    // dispatched on the associated input element. Since we are using a label element as our\n    // root container, the click event on the `checkbox` will be executed twice.\n    // The real click event will bubble up, and the generated click event also tries to bubble up.\n    // This will lead to multiple click events.\n    // Preventing bubbling for the second event will solve that issue.\n    event.stopPropagation();\n\n    // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click\n    if (!this.disabled && this._clickAction !== 'noop') {\n      // When user manually click on the checkbox, `indeterminate` is set to false.\n      if (this.indeterminate && this._clickAction !== 'check') {\n\n        Promise.resolve().then(() => {\n          this._indeterminate = false;\n          this.indeterminateChange.emit(this._indeterminate);\n        });\n      }\n\n      this.toggle();\n      this._transitionCheckState(\n          this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);\n\n      // Emit our custom change event if the native input emitted one.\n      // It is important to only emit it, if the native input triggered one, because\n      // we don't want to trigger a change event, when the `checked` variable changes for example.\n      this._emitChangeEvent();\n    } else if (!this.disabled && this._clickAction === 'noop') {\n      // Reset native input when clicked with noop. The native checkbox becomes checked after\n      // click, reset it to be align with `checked` value of `mat-checkbox`.\n      this._inputElement.nativeElement.checked = this.checked;\n      this._inputElement.nativeElement.indeterminate = this.indeterminate;\n    }\n  }\n\n  /** Focuses the checkbox. */\n  focus(): void {\n    this._focusMonitor.focusVia(this._inputElement, 'keyboard');\n  }\n\n  _onInteractionEvent(event: Event) {\n    // We always have to stop propagation on the change event.\n    // Otherwise the change event, from the input element, will bubble up and\n    // emit its event object to the `change` output.\n    event.stopPropagation();\n  }\n\n  private _getAnimationClassForCheckStateTransition(\n      oldState: TransitionCheckState, newState: TransitionCheckState): string {\n    // Don't transition if animations are disabled.\n    if (this._animationMode === 'NoopAnimations') {\n      return '';\n    }\n\n    let animSuffix: string = '';\n\n    switch (oldState) {\n      case TransitionCheckState.Init:\n        // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n        // [checked] bound to it.\n        if (newState === TransitionCheckState.Checked) {\n          animSuffix = 'unchecked-checked';\n        } else if (newState == TransitionCheckState.Indeterminate) {\n          animSuffix = 'unchecked-indeterminate';\n        } else {\n          return '';\n        }\n        break;\n      case TransitionCheckState.Unchecked:\n        animSuffix = newState === TransitionCheckState.Checked ?\n            'unchecked-checked' : 'unchecked-indeterminate';\n        break;\n      case TransitionCheckState.Checked:\n        animSuffix = newState === TransitionCheckState.Unchecked ?\n            'checked-unchecked' : 'checked-indeterminate';\n        break;\n      case TransitionCheckState.Indeterminate:\n        animSuffix = newState === TransitionCheckState.Checked ?\n            'indeterminate-checked' : 'indeterminate-unchecked';\n        break;\n    }\n\n    return `mat-checkbox-anim-${animSuffix}`;\n  }\n\n  // TODO(josephperrott): Revert to constants for ripple radius once 2018 Checkbox updates have\n  // landed.\n  /**\n   * Calculate the radius for the ripple based on the ripple elements width.  Only calculated once\n   * for the application.\n   */\n  private _calculateRippleRadius() {\n    if (!calculatedRippleRadius) {\n      const rippleWidth =\n          this._elementRef.nativeElement.querySelector('.mat-checkbox-ripple').clientWidth || 0;\n      calculatedRippleRadius = rippleWidth / 2;\n    }\n    this.ripple.radius = calculatedRippleRadius;\n  }\n}\n"]}