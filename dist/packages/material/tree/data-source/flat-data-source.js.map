{"version":3,"file":"flat-data-source.js","sourceRoot":"","sources":["../../../../../src/lib/tree/data-source/flat-data-source.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CollectionViewer, DataSource} from '@angular/cdk/collections';\nimport {FlatTreeControl, TreeControl} from '@angular/cdk/tree';\nimport {BehaviorSubject, merge, Observable} from 'rxjs';\nimport {map, take} from 'rxjs/operators';\n\n/**\n * Tree flattener to convert a normal type of node to node with children & level information.\n * Transform nested nodes of type `T` to flattened nodes of type `F`.\n *\n * For example, the input data of type `T` is nested, and contains its children data:\n *   SomeNode: {\n *     key: 'Fruits',\n *     children: [\n *       NodeOne: {\n *         key: 'Apple',\n *       },\n *       NodeTwo: {\n *        key: 'Pear',\n *      }\n *    ]\n *  }\n *  After flattener flatten the tree, the structure will become\n *  SomeNode: {\n *    key: 'Fruits',\n *    expandable: true,\n *    level: 1\n *  },\n *  NodeOne: {\n *    key: 'Apple',\n *    expandable: false,\n *    level: 2\n *  },\n *  NodeTwo: {\n *   key: 'Pear',\n *   expandable: false,\n *   level: 2\n * }\n * and the output flattened type is `F` with additional information.\n */\nexport class MatTreeFlattener<T, F> {\n\n  constructor(public transformFunction: (node: T, level: number) => F,\n              public getLevel: (node: F) => number,\n              public isExpandable: (node: F) => boolean,\n              public getChildren: (node: T) =>\n                  Observable<T[]> | T[] | undefined | null) {}\n\n  _flattenNode(node: T, level: number,\n               resultNodes: F[], parentMap: boolean[]): F[] {\n    const flatNode = this.transformFunction(node, level);\n    resultNodes.push(flatNode);\n\n    if (this.isExpandable(flatNode)) {\n      const childrenNodes = this.getChildren(node);\n      if (childrenNodes) {\n        if (Array.isArray(childrenNodes)) {\n          this._flattenChildren(childrenNodes, level, resultNodes, parentMap);\n        } else {\n          childrenNodes.pipe(take(1)).subscribe(children => {\n            this._flattenChildren(children, level, resultNodes, parentMap);\n          });\n        }\n      }\n    }\n    return resultNodes;\n  }\n\n  _flattenChildren(children: T[], level: number,\n                   resultNodes: F[], parentMap: boolean[]): void {\n    children.forEach((child, index) => {\n      let childParentMap: boolean[] = parentMap.slice();\n      childParentMap.push(index != children.length - 1);\n      this._flattenNode(child, level + 1, resultNodes, childParentMap);\n    });\n  }\n\n  /**\n   * Flatten a list of node type T to flattened version of node F.\n   * Please note that type T may be nested, and the length of `structuredData` may be different\n   * from that of returned list `F[]`.\n   */\n  flattenNodes(structuredData: T[]): F[] {\n    let resultNodes: F[] = [];\n    structuredData.forEach(node => this._flattenNode(node, 0, resultNodes, []));\n    return resultNodes;\n  }\n\n  /**\n   * Expand flattened node with current expansion status.\n   * The returned list may have different length.\n   */\n  expandFlattenedNodes(nodes: F[], treeControl: TreeControl<F>): F[] {\n    let results: F[] = [];\n    let currentExpand: boolean[] = [];\n    currentExpand[0] = true;\n\n    nodes.forEach(node => {\n      let expand = true;\n      for (let i = 0; i <= this.getLevel(node); i++) {\n        expand = expand && currentExpand[i];\n      }\n      if (expand) {\n        results.push(node);\n      }\n      if (this.isExpandable(node)) {\n        currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);\n      }\n    });\n    return results;\n  }\n}\n\n\n/**\n * Data source for flat tree.\n * The data source need to handle expansion/collapsion of the tree node and change the data feed\n * to `MatTree`.\n * The nested tree nodes of type `T` are flattened through `MatTreeFlattener`, and converted\n * to type `F` for `MatTree` to consume.\n */\nexport class MatTreeFlatDataSource<T, F> extends DataSource<F> {\n  _flattenedData = new BehaviorSubject<F[]>([]);\n\n  _expandedData = new BehaviorSubject<F[]>([]);\n\n  _data: BehaviorSubject<T[]>;\n  get data() { return this._data.value; }\n  set data(value: T[]) {\n    this._data.next(value);\n    this._flattenedData.next(this.treeFlattener.flattenNodes(this.data));\n    this.treeControl.dataNodes = this._flattenedData.value;\n  }\n\n  constructor(private treeControl: FlatTreeControl<F>,\n              private treeFlattener: MatTreeFlattener<T, F>,\n              initialData: T[] = []) {\n    super();\n    this._data = new BehaviorSubject<T[]>(initialData);\n  }\n\n  connect(collectionViewer: CollectionViewer): Observable<F[]> {\n    const changes = [\n      collectionViewer.viewChange,\n      this.treeControl.expansionModel.onChange,\n      this._flattenedData\n    ];\n    return merge(...changes).pipe(map(() => {\n      this._expandedData.next(\n        this.treeFlattener.expandFlattenedNodes(this._flattenedData.value, this.treeControl));\n      return this._expandedData.value;\n    }));\n  }\n\n  disconnect() {\n    // no op\n  }\n}\n"]}