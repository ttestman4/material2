{"version":3,"file":"tile-styler.js","sourceRoot":"","sources":["../../../../src/lib/grid-list/tile-styler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MatGridList} from './grid-list';\nimport {MatGridTile} from './grid-tile';\nimport {TileCoordinator} from './tile-coordinator';\n\n/**\n * RegExp that can be used to check whether a value will\n * be allowed inside a CSS `calc()` expression.\n */\nconst cssCalcAllowedValue = /^-?\\d+((\\.\\d+)?[A-Za-z%$]?)+$/;\n\n/**\n * Sets the style properties for an individual tile, given the position calculated by the\n * Tile Coordinator.\n * @docs-private\n */\nexport abstract class TileStyler {\n  _gutterSize: string;\n  _rows: number = 0;\n  _rowspan: number = 0;\n  _cols: number;\n  _direction: string;\n\n  /**\n   * Adds grid-list layout info once it is available. Cannot be processed in the constructor\n   * because these properties haven't been calculated by that point.\n   *\n   * @param gutterSize Size of the grid's gutter.\n   * @param tracker Instance of the TileCoordinator.\n   * @param cols Amount of columns in the grid.\n   * @param direction Layout direction of the grid.\n   */\n  init(gutterSize: string, tracker: TileCoordinator, cols: number, direction: string): void {\n    this._gutterSize = normalizeUnits(gutterSize);\n    this._rows = tracker.rowCount;\n    this._rowspan = tracker.rowspan;\n    this._cols = cols;\n    this._direction = direction;\n  }\n\n  /**\n   * Computes the amount of space a single 1x1 tile would take up (width or height).\n   * Used as a basis for other calculations.\n   * @param sizePercent Percent of the total grid-list space that one 1x1 tile would take up.\n   * @param gutterFraction Fraction of the gutter size taken up by one 1x1 tile.\n   * @return The size of a 1x1 tile as an expression that can be evaluated via CSS calc().\n   */\n  getBaseTileSize(sizePercent: number, gutterFraction: number): string {\n    // Take the base size percent (as would be if evenly dividing the size between cells),\n    // and then subtracting the size of one gutter. However, since there are no gutters on the\n    // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter\n    // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the\n    // edge evenly among the cells).\n    return `(${sizePercent}% - (${this._gutterSize} * ${gutterFraction}))`;\n  }\n\n\n  /**\n   * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.\n   * @param offset Number of tiles that have already been rendered in the row/column.\n   * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\n   * @return Position of the tile as a CSS calc() expression.\n   */\n  getTilePosition(baseSize: string, offset: number): string {\n    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\n    // row/column (offset).\n    return offset === 0 ? '0' : calc(`(${baseSize} + ${this._gutterSize}) * ${offset}`);\n  }\n\n\n  /**\n   * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.\n   * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\n   * @param span The tile's rowspan or colspan.\n   * @return Size of the tile as a CSS calc() expression.\n   */\n  getTileSize(baseSize: string, span: number): string {\n    return `(${baseSize} * ${span}) + (${span - 1} * ${this._gutterSize})`;\n  }\n\n\n  /**\n   * Sets the style properties to be applied to a tile for the given row and column index.\n   * @param tile Tile to which to apply the styling.\n   * @param rowIndex Index of the tile's row.\n   * @param colIndex Index of the tile's column.\n   */\n  setStyle(tile: MatGridTile, rowIndex: number, colIndex: number): void {\n    // Percent of the available horizontal space that one column takes up.\n    let percentWidthPerTile = 100 / this._cols;\n\n    // Fraction of the vertical gutter size that each column takes up.\n    // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.\n    let gutterWidthFractionPerTile = (this._cols - 1) / this._cols;\n\n    this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);\n    this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);\n  }\n\n  /** Sets the horizontal placement of the tile in the list. */\n  setColStyles(tile: MatGridTile, colIndex: number, percentWidth: number,\n               gutterWidth: number) {\n    // Base horizontal size of a column.\n    let baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);\n\n    // The width and horizontal position of each tile is always calculated the same way, but the\n    // height and vertical position depends on the rowMode.\n    let side = this._direction === 'rtl' ? 'right' : 'left';\n    tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));\n    tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));\n  }\n\n  /**\n   * Calculates the total size taken up by gutters across one axis of a list.\n   */\n  getGutterSpan(): string {\n    return `${this._gutterSize} * (${this._rowspan} - 1)`;\n  }\n\n  /**\n   * Calculates the total size taken up by tiles across one axis of a list.\n   * @param tileHeight Height of the tile.\n   */\n  getTileSpan(tileHeight: string): string {\n    return `${this._rowspan} * ${this.getTileSize(tileHeight, 1)}`;\n  }\n\n  /**\n   * Sets the vertical placement of the tile in the list.\n   * This method will be implemented by each type of TileStyler.\n   * @docs-private\n   */\n  abstract setRowStyles(tile: MatGridTile, rowIndex: number, percentWidth: number,\n                        gutterWidth: number): void;\n\n  /**\n   * Calculates the computed height and returns the correct style property to set.\n   * This method can be implemented by each type of TileStyler.\n   * @docs-private\n   */\n  getComputedHeight(): [string, string] | null { return null; }\n\n  /**\n   * Called when the tile styler is swapped out with a different one. To be used for cleanup.\n   * @param list Grid list that the styler was attached to.\n   * @docs-private\n   */\n  abstract reset(list: MatGridList): void;\n}\n\n\n/**\n * This type of styler is instantiated when the user passes in a fixed row height.\n * Example `<mat-grid-list cols=\"3\" rowHeight=\"100px\">`\n * @docs-private\n */\nexport class FixedTileStyler extends TileStyler {\n\n  constructor(public fixedRowHeight: string) { super(); }\n\n  init(gutterSize: string, tracker: TileCoordinator, cols: number, direction: string) {\n    super.init(gutterSize, tracker, cols, direction);\n    this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);\n\n    if (!cssCalcAllowedValue.test(this.fixedRowHeight)) {\n      throw Error(`Invalid value \"${this.fixedRowHeight}\" set as rowHeight.`);\n    }\n  }\n\n  setRowStyles(tile: MatGridTile, rowIndex: number): void {\n    tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));\n    tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));\n  }\n\n  getComputedHeight(): [string, string] {\n    return [\n      'height', calc(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)\n    ];\n  }\n\n  reset(list: MatGridList) {\n    list._setListStyle(['height', null]);\n\n    if (list._tiles) {\n      list._tiles.forEach(tile => {\n        tile._setStyle('top', null);\n        tile._setStyle('height', null);\n      });\n    }\n  }\n}\n\n\n/**\n * This type of styler is instantiated when the user passes in a width:height ratio\n * for the row height.  Example `<mat-grid-list cols=\"3\" rowHeight=\"3:1\">`\n * @docs-private\n */\nexport class RatioTileStyler extends TileStyler {\n\n  /** Ratio width:height given by user to determine row height. */\n  rowHeightRatio: number;\n  baseTileHeight: string;\n\n  constructor(value: string) {\n    super();\n    this._parseRatio(value);\n  }\n\n  setRowStyles(tile: MatGridTile, rowIndex: number, percentWidth: number,\n               gutterWidth: number): void {\n    let percentHeightPerTile = percentWidth / this.rowHeightRatio;\n    this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);\n\n    // Use padding-top and margin-top to maintain the given aspect ratio, as\n    // a percentage-based value for these properties is applied versus the *width* of the\n    // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\n    tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));\n    tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));\n  }\n\n  getComputedHeight(): [string, string] {\n    return [\n      'paddingBottom', calc(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)\n    ];\n  }\n\n  reset(list: MatGridList) {\n    list._setListStyle(['paddingBottom', null]);\n\n    list._tiles.forEach(tile => {\n      tile._setStyle('marginTop', null);\n      tile._setStyle('paddingTop', null);\n    });\n  }\n\n  private _parseRatio(value: string): void {\n    const ratioParts = value.split(':');\n\n    if (ratioParts.length !== 2) {\n      throw Error(`mat-grid-list: invalid ratio given for row-height: \"${value}\"`);\n    }\n\n    this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);\n  }\n}\n\n/**\n * This type of styler is instantiated when the user selects a \"fit\" row height mode.\n * In other words, the row height will reflect the total height of the container divided\n * by the number of rows.  Example `<mat-grid-list cols=\"3\" rowHeight=\"fit\">`\n *\n * @docs-private\n */\nexport class FitTileStyler extends TileStyler {\n  setRowStyles(tile: MatGridTile, rowIndex: number): void {\n    // Percent of the available vertical space that one row takes up.\n    let percentHeightPerTile = 100 / this._rowspan;\n\n    // Fraction of the horizontal gutter size that each column takes up.\n    let gutterHeightPerTile = (this._rows - 1) / this._rows;\n\n    // Base vertical size of a column.\n    let baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);\n\n    tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));\n    tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));\n  }\n\n  reset(list: MatGridList) {\n    if (list._tiles) {\n      list._tiles.forEach(tile => {\n        tile._setStyle('top', null);\n        tile._setStyle('height', null);\n      });\n    }\n  }\n}\n\n\n/** Wraps a CSS string in a calc function */\nfunction calc(exp: string): string {\n  return `calc(${exp})`;\n}\n\n\n/** Appends pixels to a CSS string if no units are given. */\nfunction normalizeUnits(value: string): string {\n  return value.match(/([A-Za-z%]+)$/) ? value : `${value}px`;\n}\n\n"]}